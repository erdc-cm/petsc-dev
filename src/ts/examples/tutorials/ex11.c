static char help[] = "Second Order TVD Finite Volume Example.\n";
/*
  The mesh is read in from an ExodusII file generated by Cubit.
*/
#include <petscts.h>
#include <petscdmcomplex.h>
#ifdef PETSC_HAVE_EXODUSII
#include <exodusII.h>
#else
#error This example requires ExodusII support. Reconfigure using --download-exodusii
#endif

typedef struct {
  PetscInt     numGhostCells, cEndInterior;
  PetscSection normalSection;
  Vec          normals;
  PetscSection centroidSection;
  Vec          centroids;
} AppCtx;

#undef __FUNCT__
#define __FUNCT__ "ConstructGhostCells"
PetscErrorCode ConstructGhostCells(DM *dmGhosted, AppCtx *user)
{
  DM              dm = *dmGhosted, gdm;
  PetscSection    coordSection, newCoordSection;
  Vec             coordinates;
  const char     *name = "Face Sets";
  IS              idIS;
  const PetscInt *ids;
  PetscInt       *newpoints;
  PetscInt        dim, depth, d, maxConeSize, maxSupportSize, numLabels, l;
  PetscInt        numFS, fs, pStart, pEnd, p, cStart, cEnd, c, ghostCell, vStart, vEnd, v;
  PetscErrorCode  ierr;

  PetscFunctionBegin;
  ierr = DMCreate(((PetscObject) dm)->comm, &gdm);CHKERRQ(ierr);
  ierr = DMSetType(gdm, DMCOMPLEX);CHKERRQ(ierr);
  ierr = DMComplexGetDimension(dm, &dim);CHKERRQ(ierr);
  ierr = DMComplexSetDimension(gdm, dim);CHKERRQ(ierr);

  ierr = DMComplexGetLabelIdIS(dm, name, &idIS);CHKERRQ(ierr);
  ierr = ISGetLocalSize(idIS, &numFS);CHKERRQ(ierr);
  ierr = ISGetIndices(idIS, &ids);CHKERRQ(ierr);
  user->numGhostCells = 0;
  for(fs = 0; fs < numFS; ++fs) {
    PetscInt numBdFaces;

    ierr = DMComplexGetStratumSize(dm, name, ids[fs], &numBdFaces);CHKERRQ(ierr);
    user->numGhostCells += numBdFaces;
  }
  ierr = DMComplexGetChart(dm, &pStart, &pEnd);CHKERRQ(ierr);
  pEnd += user->numGhostCells;
  ierr = DMComplexSetChart(gdm, pStart, pEnd);CHKERRQ(ierr);
  /* Set cone and support sizes */
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  user->cEndInterior = cEnd;
  for(c = cStart; c < cEnd; ++c) {
    PetscInt size;

    ierr = DMComplexGetConeSize(dm, c, &size);CHKERRQ(ierr);
    ierr = DMComplexSetConeSize(gdm, c, size);CHKERRQ(ierr);
  }
  for(c = cEnd; c < cEnd+user->numGhostCells; ++c) {
    ierr = DMComplexSetConeSize(gdm, c, 1);CHKERRQ(ierr);
  }
  ierr = DMComplexGetDepth(dm, &depth);CHKERRQ(ierr);
  for(d = 0; d < depth; ++d) {
    ierr = DMComplexGetDepthStratum(dm, d, &pStart, &pEnd);CHKERRQ(ierr);
    for(p = pStart; p < pEnd; ++p) {
      PetscInt newp = p+user->numGhostCells;
      PetscInt size;

      ierr = DMComplexGetConeSize(dm, p, &size);CHKERRQ(ierr);
      ierr = DMComplexSetConeSize(gdm, newp, size);CHKERRQ(ierr);
      ierr = DMComplexGetSupportSize(dm, p, &size);CHKERRQ(ierr);
      ierr = DMComplexSetSupportSize(gdm, newp, size);CHKERRQ(ierr);
    }
  }
  for(fs = 0; fs < numFS; ++fs) {
    IS              faceIS;
    const PetscInt *faces;
    PetscInt        numFaces, f;

    ierr = DMComplexGetStratumIS(dm, name, ids[fs], &faceIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(faceIS, &numFaces);CHKERRQ(ierr);
    ierr = ISGetIndices(faceIS, &faces);CHKERRQ(ierr);
    for(f = 0; f < numFaces; ++f) {
      PetscInt size;

      ierr = DMComplexGetSupportSize(dm, faces[f], &size);CHKERRQ(ierr);
      if (size != 1) SETERRQ2(((PetscObject) dm)->comm, PETSC_ERR_ARG_WRONG, "DM has boundary face %d with %d support cells", faces[f], size);
      ierr = DMComplexSetSupportSize(gdm, faces[f]+user->numGhostCells, 2);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(faceIS, &faces);CHKERRQ(ierr);
    ierr = ISDestroy(&faceIS);CHKERRQ(ierr);
  }
  ierr = DMSetUp(gdm);CHKERRQ(ierr);
  /* Set cones and supports, may have to orient supports here */
  ierr = DMComplexGetMaxSizes(dm, &maxConeSize, &maxSupportSize);CHKERRQ(ierr);
  ierr = PetscMalloc(PetscMax(maxConeSize, maxSupportSize) * sizeof(PetscInt), &newpoints);CHKERRQ(ierr);
  ierr = DMComplexGetChart(dm, &pStart, &pEnd);CHKERRQ(ierr);
  for(p = pStart; p < pEnd; ++p) {
    const PetscInt *points, *orientations;
    PetscInt        size, i, newp = p >= cEnd ? p+user->numGhostCells : p;

    ierr = DMComplexGetConeSize(dm, p, &size);CHKERRQ(ierr);
    ierr = DMComplexGetCone(dm, p, &points);CHKERRQ(ierr);
    ierr = DMComplexGetConeOrientation(dm, p, &orientations);CHKERRQ(ierr);
    for(i = 0; i < size; ++i) {
      newpoints[i] = points[i] >= cEnd ? points[i]+user->numGhostCells : points[i];
    }
    ierr = DMComplexSetCone(gdm, newp, newpoints);CHKERRQ(ierr);
    ierr = DMComplexSetConeOrientation(gdm, newp, orientations);CHKERRQ(ierr);
    ierr = DMComplexGetSupportSize(dm, p, &size);CHKERRQ(ierr);
    ierr = DMComplexGetSupport(dm, p, &points);CHKERRQ(ierr);
    for(i = 0; i < size; ++i) {
      newpoints[i] = points[i] >= cEnd ? points[i]+user->numGhostCells : points[i];
    }
    ierr = DMComplexSetSupport(gdm, newp, newpoints);CHKERRQ(ierr);
  }
  ierr = PetscFree(newpoints);CHKERRQ(ierr);
  ghostCell = cEnd;
  for(fs = 0; fs < numFS; ++fs) {
    IS              faceIS;
    const PetscInt *faces;
    PetscInt        numFaces, f;

    ierr = DMComplexGetStratumIS(dm, name, ids[fs], &faceIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(faceIS, &numFaces);CHKERRQ(ierr);
    ierr = ISGetIndices(faceIS, &faces);CHKERRQ(ierr);
    for(f = 0; f < numFaces; ++f, ++ghostCell) {
      PetscInt newFace = faces[f] + user->numGhostCells;

      ierr = DMComplexSetCone(gdm, ghostCell, &newFace);CHKERRQ(ierr);
      ierr = DMComplexInsertSupport(gdm, newFace, 1, ghostCell);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(faceIS, &faces);CHKERRQ(ierr);
    ierr = ISDestroy(&faceIS);CHKERRQ(ierr);
  }
  ierr = ISRestoreIndices(idIS, &ids);CHKERRQ(ierr);
  ierr = ISDestroy(&idIS);CHKERRQ(ierr);
  ierr = DMComplexStratify(gdm);CHKERRQ(ierr);
  /* Convert coordinates */
  ierr = DMComplexGetDepthStratum(dm, 0, &vStart, &vEnd);CHKERRQ(ierr);
  ierr = DMComplexGetCoordinateSection(dm, &coordSection);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &newCoordSection);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(newCoordSection, vStart+user->numGhostCells, vEnd+user->numGhostCells);CHKERRQ(ierr);
  for(v = vStart; v < vEnd; ++v) {
    ierr = PetscSectionSetDof(newCoordSection, v+user->numGhostCells, dim);CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(newCoordSection);CHKERRQ(ierr);
  ierr = DMComplexSetCoordinateSection(gdm, newCoordSection);CHKERRQ(ierr);
  ierr = DMGetCoordinatesLocal(dm, &coordinates);CHKERRQ(ierr);
  ierr = DMSetCoordinatesLocal(gdm, coordinates);CHKERRQ(ierr);
  /* Convert labels */
  ierr = DMComplexGetNumLabels(dm, &numLabels);CHKERRQ(ierr);
  for(l = 0; l < numLabels; ++l) {
    const char *lname;
    PetscBool   isDepth;

    ierr = DMComplexGetLabelName(dm, l, &lname);CHKERRQ(ierr);
    ierr = PetscStrcmp(lname, "depth", &isDepth);CHKERRQ(ierr);
    if (isDepth) continue;
    ierr = DMComplexGetLabelIdIS(dm, lname, &idIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(idIS, &numFS);CHKERRQ(ierr);
    ierr = ISGetIndices(idIS, &ids);CHKERRQ(ierr);
    for(fs = 0; fs < numFS; ++fs) {
      IS              pointIS;
      const PetscInt *points;
      PetscInt        numPoints;

      ierr = DMComplexGetStratumIS(dm, lname, ids[fs], &pointIS);CHKERRQ(ierr);
      ierr = ISGetLocalSize(pointIS, &numPoints);CHKERRQ(ierr);
      ierr = ISGetIndices(pointIS, &points);CHKERRQ(ierr);
      for(p = 0; p < numPoints; ++p) {
        PetscInt newpoint = points[p] >= cEnd ? points[p]+user->numGhostCells : points[p];

        ierr = DMComplexSetLabelValue(gdm, lname, newpoint, ids[fs]);CHKERRQ(ierr);
      }
      ierr = ISRestoreIndices(pointIS, &points);CHKERRQ(ierr);
      ierr = ISDestroy(&pointIS);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(idIS, &ids);CHKERRQ(ierr);
    ierr = ISDestroy(&idIS);CHKERRQ(ierr);
  }
  /* Turn off visualization of ghost cells */
  ierr = DMComplexSetVTKBounds(gdm, cEnd, PETSC_DETERMINE);CHKERRQ(ierr);

  ierr = DMSetFromOptions(gdm);CHKERRQ(ierr);
  ierr = DMDestroy(dmGhosted);CHKERRQ(ierr);
  *dmGhosted = gdm;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "ConstructGeometry"
/* Iterate over all faces and give me the area-scaled normal vector and centroids */
PetscErrorCode ConstructGeometry(DM dm, PetscSection normalSection, Vec normals, PetscSection centroidSection, Vec centroids)
{
  PetscSection   coordSection;
  Vec            coordinates;
  PetscScalar   *n;
  PetscInt       dim, normalSize, centroidSize, cStart, cEnd, c, fStart, fEnd, f;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMComplexGetDimension(dm, &dim);CHKERRQ(ierr);
  ierr = DMComplexGetCoordinateSection(dm, &coordSection);CHKERRQ(ierr);
  ierr = DMGetCoordinatesLocal(dm, &coordinates);CHKERRQ(ierr);
  /* Make normals */
  ierr = DMComplexGetHeightStratum(dm, 1, &fStart, &fEnd);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(normalSection, fStart, fEnd);CHKERRQ(ierr);
  for(f = fStart; f < fEnd; ++f) {
    ierr = PetscSectionSetDof(normalSection, f, dim);CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(normalSection);CHKERRQ(ierr);
  ierr = PetscSectionGetStorageSize(normalSection, &normalSize);CHKERRQ(ierr);
  ierr = VecSetSizes(normals, normalSize, PETSC_DETERMINE);CHKERRQ(ierr);
  ierr = VecSetFromOptions(normals);CHKERRQ(ierr);
  ierr = VecGetArray(normals, &n);CHKERRQ(ierr);
  for(f = fStart; f < fEnd; ++f) {
    const PetscScalar *coords = PETSC_NULL;
    PetscInt           coordSize, off, d;
    PetscReal          v[2], mag = 0.0;

    ierr = DMComplexVecGetClosure(dm, coordSection, coordinates, f, &coordSize, &coords);CHKERRQ(ierr);
    /* Only support edges right now */
    if (coordSize != dim*2) SETERRQ(((PetscObject) dm)->comm, PETSC_ERR_SUP, "We only support edges right now");
    v[0] =  (coords[1] - coords[dim+1]);
    v[1] = -(coords[0] - coords[dim+0]);
    ierr = DMComplexVecRestoreClosure(dm, coordSection, coordinates, f, &coordSize, &coords);CHKERRQ(ierr);
    for(d = 0; d < dim; ++d) {mag += PetscSqr(v[d]);}
    mag  = sqrt(mag);
    ierr = PetscSectionGetOffset(normalSection, f, &off);CHKERRQ(ierr);
#if 0
    for(d = 0; d < dim; ++d) {n[off+d] = v[d]/mag;}
#else
    /* I think this is the area scaling you want */
    for(d = 0; d < dim; ++d) {n[off+d] = v[d];}
#endif
  }
  ierr = VecRestoreArray(normals, &n);CHKERRQ(ierr);
  /* Make centroids */
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(centroidSection, cStart, cEnd);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    ierr = PetscSectionSetDof(centroidSection, c, dim);CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(centroidSection);CHKERRQ(ierr);
  ierr = PetscSectionGetStorageSize(centroidSection, &centroidSize);CHKERRQ(ierr);
  ierr = VecSetSizes(centroids, centroidSize, PETSC_DETERMINE);CHKERRQ(ierr);
  ierr = VecSetFromOptions(centroids);CHKERRQ(ierr);
  ierr = VecGetArray(centroids, &n);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    const PetscScalar *coords = PETSC_NULL;
    PetscInt           coordSize, off, d, numCorners, p;
    PetscReal          centroid[3] = {0.0, 0.0, 0.0};

    ierr = DMComplexVecGetClosure(dm, coordSection, coordinates, c, &coordSize, &coords);CHKERRQ(ierr);
    numCorners = coordSize/dim;
    for(p = 0; p < numCorners; ++p) {
      for(d = 0; d < dim; ++d) {
        centroid[d] += coords[p*dim+d];
      }
    }
    for(d = 0; d < dim; ++d) {
      centroid[d] /= numCorners;
    }
    ierr = DMComplexVecRestoreClosure(dm, coordSection, coordinates, f, &coordSize, &coords);CHKERRQ(ierr);
    ierr = PetscSectionGetOffset(centroidSection, c, &off);CHKERRQ(ierr);
    for(d = 0; d < dim; ++d) {n[off+d] = centroid[d];}
  }
  ierr = VecRestoreArray(centroids, &n);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#define __FUNCT__ "SetUpLocalSpace"
PetscErrorCode SetUpLocalSpace(DM dm, PetscInt numGhostCells)
{
  PetscSection   stateSection;
  PetscInt       dof = 1, *cind, d, stateSize, cStart, cEnd, c;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &stateSection);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(stateSection, cStart, cEnd);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    ierr = PetscSectionSetDof(stateSection, c, dof);CHKERRQ(ierr);
  }
  for(c = cEnd-numGhostCells; c < cEnd; ++c) {
    ierr = PetscSectionSetConstraintDof(stateSection, c, dof);CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(stateSection);CHKERRQ(ierr);
  ierr = PetscMalloc(dof * sizeof(PetscInt), &cind);CHKERRQ(ierr);
  for(d = 0; d < dof; ++d) cind[d] = d;
  for(c = cEnd-numGhostCells; c < cEnd; ++c) {
    ierr = PetscSectionSetConstraintIndices(stateSection, c, cind);CHKERRQ(ierr);
  }
  ierr = PetscFree(cind);CHKERRQ(ierr);
  ierr = PetscSectionGetStorageSize(stateSection, &stateSize);CHKERRQ(ierr);
  ierr = DMSetDefaultSection(dm, stateSection);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "CopyToGhosts"
/* Iterate over boundary faces copying state from the cell inside into the ghost cell. */
PetscErrorCode CopyToGhosts(DM dm, AppCtx *user, Vec locX)
{
  const char     *name = "Face Sets";
  IS              idIS;
  const PetscInt *ids;
  PetscSection    stateSection;
  PetscScalar    *state;
  PetscInt        numFS, fs;
  PetscErrorCode  ierr;

  PetscFunctionBegin;
  ierr = DMGetDefaultSection(dm, &stateSection);CHKERRQ(ierr);
  ierr = DMComplexGetLabelIdIS(dm, name, &idIS);CHKERRQ(ierr);
  ierr = ISGetLocalSize(idIS, &numFS);CHKERRQ(ierr);
  ierr = ISGetIndices(idIS, &ids);CHKERRQ(ierr);
  ierr = VecGetArray(locX, &state);CHKERRQ(ierr);
  for(fs = 0; fs < numFS; ++fs) {
    IS              faceIS;
    const PetscInt *faces;
    PetscInt        numFaces, f;

    ierr = DMComplexGetStratumIS(dm, name, ids[fs], &faceIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(faceIS, &numFaces);CHKERRQ(ierr);
    ierr = ISGetIndices(faceIS, &faces);CHKERRQ(ierr);
    for(f = 0; f < numFaces; ++f) {
      const PetscInt  face = faces[f];
      const PetscInt *cells;
      PetscInt        numCells;

      ierr = DMComplexGetSupportSize(dm, face, &numCells);CHKERRQ(ierr);
      ierr = DMComplexGetSupport(dm, face, &cells);CHKERRQ(ierr);
      if (numCells != 2) SETERRQ2(((PetscObject) dm)->comm, PETSC_ERR_ARG_WRONG, "DM has %d > 2 cells for face %d", numCells, f);
      PetscInt dof, off, gdof, goff, d;

      ierr = PetscSectionGetDof(stateSection, cells[0], &dof);CHKERRQ(ierr);
      ierr = PetscSectionGetOffset(stateSection, cells[0], &off);CHKERRQ(ierr);
      ierr = PetscSectionGetDof(stateSection, cells[1], &gdof);CHKERRQ(ierr);
      ierr = PetscSectionGetOffset(stateSection, cells[1], &goff);CHKERRQ(ierr);
      for(d = 0; d < dof; ++d) {
        state[goff+d] = state[off+d];
      }
    }
    ierr = ISRestoreIndices(faceIS, &faces);CHKERRQ(ierr);
    ierr = ISDestroy(&faceIS);CHKERRQ(ierr);
  }
  ierr = VecRestoreArray(locX, &state);CHKERRQ(ierr);
  ierr = ISRestoreIndices(idIS, &ids);CHKERRQ(ierr);
  ierr = ISDestroy(&idIS);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SetInitialCondition"
PetscErrorCode SetInitialCondition(DM dm, Vec X, AppCtx *user)
{
  Vec            locX;
  PetscSection   section;
  PetscScalar   *x, *centroids;
  PetscInt       cStart, cEnd, cEndInterior = user->cEndInterior, c;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = DMGetDefaultSection(dm, &section);CHKERRQ(ierr);
  ierr = DMGetLocalVector(dm, &locX);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->centroids, &centroids);CHKERRQ(ierr);
  ierr = VecGetArray(locX, &x);CHKERRQ(ierr);
  for(c = cStart; c < cEndInterior; ++c) {
    PetscInt off, coff;

    ierr = PetscSectionGetOffset(section, c, &off);CHKERRQ(ierr);
    ierr = PetscSectionGetOffset(user->centroidSection, c, &coff);CHKERRQ(ierr);
    x[off] = centroids[coff+0] + 3*centroids[coff+1];
  }
  ierr = VecRestoreArrayRead(user->centroids, &centroids);CHKERRQ(ierr);
  ierr = VecRestoreArray(locX, &x);CHKERRQ(ierr);
  ierr = DMLocalToGlobalBegin(dm, locX, INSERT_VALUES, X);CHKERRQ(ierr);
  ierr = DMLocalToGlobalEnd(dm, locX, INSERT_VALUES, X);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm, &locX);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "CalculateFlux"
/* Iterate over all faces and give me access to solution state + residual for the cells on both sides. */
PetscErrorCode CalculateFlux(DM dm, AppCtx *user, Vec locX, Vec locF)
{
  PetscSection   stateSection;
  PetscScalar   *state, *residual;
  PetscInt       fStart, fEnd, f;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMGetDefaultSection(dm, &stateSection);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 1, &fStart, &fEnd);CHKERRQ(ierr);
  ierr = VecGetArray(locX, &state);CHKERRQ(ierr);
  ierr = VecGetArray(locF, &residual);CHKERRQ(ierr);
  for(f = fStart; f < fEnd; ++f) {
    const PetscInt *cells;
    PetscInt        numCells, c;

    ierr = DMComplexGetSupportSize(dm, f, &numCells);CHKERRQ(ierr);
    ierr = DMComplexGetSupport(dm, f, &cells);CHKERRQ(ierr);
    if (numCells != 2) SETERRQ2(((PetscObject) dm)->comm, PETSC_ERR_ARG_WRONG, "DM has %d > 2 cells for face %d", numCells, f);
    for(c = 0; c < numCells; ++c) {
      PetscInt dof, off, d;

      ierr = PetscSectionGetDof(stateSection, cells[c], &dof);CHKERRQ(ierr);
      ierr = PetscSectionGetOffset(stateSection, cells[c], &off);CHKERRQ(ierr);
      for(d = 0; d < dof; ++d) {
        residual[off+d] = state[off+d];
      }
    }
  }
  ierr = VecRestoreArray(locX, &state);CHKERRQ(ierr);
  ierr = VecRestoreArray(locF, &residual);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "main"
int main(int argc, char **argv)
{
  MPI_Comm       comm;
  AppCtx         user;
  DM             dm;
  PetscInt       exoid;
  int            CPU_word_size = 0, IO_word_size = 0;
  float          version;
  TS             ts;
  Vec            X, locX, locF;
  PetscMPIInt    rank;
  char           filename[PETSC_MAX_PATH_LEN] = "sevenside.exo";
  PetscErrorCode ierr;

  ierr = PetscInitialize(&argc, &argv, (char *) 0, help);CHKERRQ(ierr);
  comm = PETSC_COMM_WORLD;
  ierr = MPI_Comm_rank(comm, &rank);CHKERRQ(ierr);

  ierr = PetscOptionsBegin(comm,PETSC_NULL,"Unstructured Finite Volume Options","");CHKERRQ(ierr);
  ierr = PetscOptionsString("-f", "Exodus.II filename to read", "", filename, filename, sizeof(filename), PETSC_NULL);CHKERRQ(ierr);
  ierr = PetscOptionsEnd();CHKERRQ(ierr);

  if (!rank) {
    exoid = ex_open(filename, EX_READ, &CPU_word_size, &IO_word_size, &version);
    if (exoid <= 0) SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_LIB,"ex_open(\"%s\",...) did not return a valid file ID",filename);
  }
  ierr = DMComplexCreateExodus(comm, exoid, PETSC_TRUE, &dm);CHKERRQ(ierr);
  if (!rank) {ierr = ex_close(exoid);CHKERRQ(ierr);}
  ierr = DMSetFromOptions(dm);CHKERRQ(ierr);

  ierr = ConstructGhostCells(&dm, &user);CHKERRQ(ierr);

  ierr = TSCreate(comm, &ts);CHKERRQ(ierr);
  ierr = TSSetProblemType(ts, TS_NONLINEAR);CHKERRQ(ierr);
  ierr = TSSetType(ts, TSROSW);CHKERRQ(ierr);
  ierr = TSSetDM(ts, dm);CHKERRQ(ierr);

  ierr = PetscSectionCreate(comm, &user.normalSection);CHKERRQ(ierr);
  ierr = VecCreate(comm, &user.normals);CHKERRQ(ierr);
  ierr = PetscSectionCreate(comm, &user.centroidSection);CHKERRQ(ierr);
  ierr = VecCreate(comm, &user.centroids);CHKERRQ(ierr);
  ierr = ConstructGeometry(dm, user.normalSection, user.normals, user.centroidSection, user.centroids);CHKERRQ(ierr);
  ierr = VecView(user.normals, PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);

  /* Set up DM with section describing local vector and configure local vector. */
  ierr = SetUpLocalSpace(dm, user.numGhostCells);CHKERRQ(ierr);

  ierr = DMCreateGlobalVector(dm, &X);CHKERRQ(ierr);
  ierr = SetInitialCondition(dm, X, &user);CHKERRQ(ierr);
  { /* Matt refuses to compose the DM with the Vec so that VecView() would work, hence this atrocity. */
    const char *name;
    Vec XLoc;
    PetscViewer viewer;
    PetscSection section;
    PetscContainer c;

    ierr = PetscViewerCreate(comm,&viewer);CHKERRQ(ierr);
    ierr = PetscViewerSetType(viewer,PETSCVIEWERVTK);CHKERRQ(ierr);
    ierr = PetscViewerFileSetName(viewer,"ex11_sol.vtk");CHKERRQ(ierr);
    ierr = PetscViewerSetFormat(viewer,PETSC_VIEWER_ASCII_VTK);CHKERRQ(ierr);
    ierr = DMGetLocalVector(dm,&XLoc);CHKERRQ(ierr);
    ierr = PetscObjectGetName((PetscObject)X,&name);CHKERRQ(ierr);
    ierr = PetscObjectSetName((PetscObject)XLoc,name);CHKERRQ(ierr);
    ierr = DMGlobalToLocalBegin(dm,X,INSERT_VALUES,XLoc);CHKERRQ(ierr);
    ierr = DMGlobalToLocalEnd(dm,X,INSERT_VALUES,XLoc);CHKERRQ(ierr);
    ierr = DMGetDefaultSection(dm,&section);CHKERRQ(ierr);
    ierr = PetscObjectReference((PetscObject)dm);CHKERRQ(ierr); /* Needed because viewer destroys the DM */
    ierr = PetscObjectReference((PetscObject)XLoc);CHKERRQ(ierr); /* Needed because viewer destroys the Vec */
    ierr = PetscContainerCreate(comm,&c);CHKERRQ(ierr);
    ierr = PetscContainerSetPointer(c,section);CHKERRQ(ierr);
    ierr = PetscObjectCompose((PetscObject)XLoc,"section",(PetscObject)c);CHKERRQ(ierr);
    ierr = PetscContainerDestroy(&c);CHKERRQ(ierr);

    ierr = PetscViewerVTKAddField(viewer,(PetscObject)dm,DMComplexVTKWriteAll,PETSC_VTK_CELL_FIELD,(PetscObject)XLoc);CHKERRQ(ierr);
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
    ierr = DMRestoreLocalVector(dm,&XLoc);CHKERRQ(ierr);
  }

  ierr = DMGetLocalVector(dm, &locX);CHKERRQ(ierr);
  ierr = DMGetLocalVector(dm, &locF);CHKERRQ(ierr);
  ierr = CopyToGhosts(dm, &user, locX);CHKERRQ(ierr);
  ierr = CalculateFlux(dm, &user, locX, locF);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm, &locX);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm, &locF);CHKERRQ(ierr);

  ierr = PetscSectionDestroy(&user.normalSection);CHKERRQ(ierr);
  ierr = VecDestroy(&user.normals);CHKERRQ(ierr);
  ierr = PetscSectionDestroy(&user.centroidSection);CHKERRQ(ierr);
  ierr = VecDestroy(&user.centroids);CHKERRQ(ierr);
  ierr = VecDestroy(&X);CHKERRQ(ierr);
  ierr = DMDestroy(&dm);CHKERRQ(ierr);
  ierr = TSDestroy(&ts);CHKERRQ(ierr);
  ierr = PetscFinalize();
  return(0);
}
