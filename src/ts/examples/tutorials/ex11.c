static char help[] = "Second Order TVD Finite Volume Example.\n";
/*
  The mesh is read in from an ExodusII file generated by Cubit.
*/
#include <petscts.h>
#include <petscdmcomplex.h>
#include <petscblaslapack.h>
#ifdef PETSC_HAVE_EXODUSII
#include <exodusII.h>
#else
#error This example requires ExodusII support. Reconfigure using --download-exodusii
#endif

#define DIM 2                   /* Geometric dimension */
#define ALEN(a) (sizeof(a)/sizeof((a)[0]))

static PetscFList PhysicsList;

typedef struct _n_User *User;
typedef struct _n_Physics *Physics;

typedef PetscErrorCode (*SolutionFunction)(User,PetscReal,const PetscReal*,PetscScalar*);
typedef PetscErrorCode (*BoundaryFunction)(Physics,const PetscReal*,const PetscScalar*,PetscScalar*);
typedef PetscErrorCode (*RiemannFunction)(Physics,const PetscReal*,const PetscScalar*,const PetscScalar*,PetscScalar*);
typedef PetscErrorCode (*MonitorFunction)(Physics,const PetscScalar*,PetscReal*);
static PetscErrorCode PhysicsBoundaryRegister(Physics,const char*,BoundaryFunction,PetscInt,const PetscInt*);
static PetscErrorCode PhysicsFunctionalRegister(Physics,const char*,PetscInt*);
static PetscErrorCode OutputVTK(DM,const char *,PetscViewer*);

typedef struct _n_BoundaryLink *BoundaryLink;
struct _n_BoundaryLink {
  BoundaryFunction func;
  char             *name;
  PetscInt         numids;
  PetscInt         *ids;
  BoundaryLink     next;
};

typedef struct _n_FunctionalLink *FunctionalLink;
struct _n_FunctionalLink {
  char *name;
  PetscInt offset;
  FunctionalLink next;
};

struct _n_Physics {
  RiemannFunction riemann;
  SolutionFunction solution;
  MonitorFunction monitor;
  BoundaryLink boundary;
  FunctionalLink functional;
  PetscInt  dof;                /* number of degrees of freedom per cell */
  PetscReal maxspeed;           /* estimate of global maximum speed (for CFL calculation) */
  void *data;
};

struct _n_User {
  MPI_Comm  comm;
  PetscErrorCode (*RHSFunctionLocal)(DM,DM,DM,Vec,Vec,User);
  PetscBool reconstruct;
  PetscInt  numGhostCells;
  PetscInt  cEndInterior;  /* First boundary ghost cell */
  Vec       cellgeom, facegeom;
  DM        dmGrad;
  PetscReal minradius;
  PetscInt  vtkInterval;        /* For monitor */
  Physics   physics;
  struct {
    PetscScalar *flux;
    PetscScalar *state0;
    PetscScalar *state1;
  } work;
};

typedef struct {
  PetscScalar normal[DIM];              /* Area-scaled normals */
  PetscScalar centroid[DIM];            /* Location of centroid (quadrature point) */
  PetscScalar grad[2][DIM];             /* Face contribution to gradient in left and right cell */
} FaceGeom;

typedef struct {
  PetscScalar centroid[DIM];
  PetscScalar volume;
} CellGeom;

PETSC_STATIC_INLINE PetscScalar Dot2(const PetscScalar *x,const PetscScalar *y) { return x[0]*y[0] + x[1]*y[1];}
PETSC_STATIC_INLINE PetscReal Norm2(const PetscScalar *x) { return PetscSqrtReal(PetscAbsScalar(Dot2(x,x)));}
PETSC_STATIC_INLINE void Normalize2(PetscScalar *x) { PetscReal a = 1./Norm2(x); x[0] *= a; x[1] *= a; }
PETSC_STATIC_INLINE void Waxpy2(PetscScalar a,const PetscScalar *x,const PetscScalar *y,PetscScalar *w) { w[0] = a*x[0] + y[0]; w[1] = a*x[1] + y[1]; }
PETSC_STATIC_INLINE void Scale2(PetscScalar a,const PetscScalar *x,PetscScalar *y) { y[0] = a*x[0]; y[1] = a*x[1]; }

PETSC_STATIC_INLINE void NormalSplit(const PetscReal *n,const PetscScalar *x,PetscScalar *xn,PetscScalar *xt)
{                               /* Split x into normal and tangential components */
  Scale2(Dot2(x,n)/Dot2(n,n),n,xn);
  Waxpy2(-1,xn,x,xt);
}

/******************* Advect ********************/
typedef struct {
  PetscReal wind[DIM];
  PetscReal inflowState;
} Physics_Advect;

#undef __FUNCT__
#define __FUNCT__ "PhysicsBoundary_Advect_Inflow"
static PetscErrorCode PhysicsBoundary_Advect_Inflow(Physics phys, const PetscReal *n, const PetscScalar *xI, PetscScalar *xG)
{
  Physics_Advect *advect = (Physics_Advect*)phys->data;

  PetscFunctionBegin;
  xG[0] = advect->inflowState;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsBoundary_Advect_Outflow"
static PetscErrorCode PhysicsBoundary_Advect_Outflow(Physics phys, const PetscReal *n, const PetscScalar *xI, PetscScalar *xG)
{
  PetscFunctionBegin;
  xG[0] = xI[0];
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsRiemann_Advect"
static PetscErrorCode PhysicsRiemann_Advect(Physics phys, const PetscReal *n, const PetscScalar *xL, const PetscScalar *xR, PetscScalar *flux)
{
  Physics_Advect *advect = (Physics_Advect*)phys->data;
  PetscReal wn;

  PetscFunctionBegin;
  wn = Dot2(advect->wind, n);
  flux[0] = (wn > 0 ? xL[0] : xR[0]) * wn;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsSolution_Advect"
static PetscErrorCode PhysicsSolution_Advect(User user,PetscReal time,const PetscReal *x,PetscScalar *u)
{
  Physics_Advect *advect = (Physics_Advect*)user->physics->data;
  PetscReal x0[2];

  PetscFunctionBegin;
  Waxpy2(-time,advect->wind,x,x0);
  if (x0[1] > 0) u[0] = 1.*x[0] + 3.*x[1];
  else u[0] = advect->inflowState;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsCreate_Advect"
static PetscErrorCode PhysicsCreate_Advect(User user,Physics phys)
{
  const PetscInt inflowids[] = {100,200,300},outflowids[] = {101};
  Physics_Advect *advect = (Physics_Advect*)phys->data;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = PhysicsBoundaryRegister(phys,"inflow",PhysicsBoundary_Advect_Inflow,ALEN(inflowids),inflowids);CHKERRQ(ierr);
  ierr = PhysicsBoundaryRegister(phys,"outflow",PhysicsBoundary_Advect_Outflow,ALEN(outflowids),outflowids);CHKERRQ(ierr);
  phys->dof = 1;
  phys->riemann = PhysicsRiemann_Advect;
  phys->solution = PhysicsSolution_Advect;
  ierr = PetscNew(Physics_Advect,&phys->data);CHKERRQ(ierr);
  advect = phys->data;
  ierr = PetscOptionsHead("Advect options");CHKERRQ(ierr);
  {
    PetscInt two = 2,dof = 1;
    advect->wind[0] = 0.0;
    advect->wind[1] = 1.0;
    ierr = PetscOptionsRealArray("-advect_wind","background wind vx,vy","",advect->wind,&two,PETSC_NULL);CHKERRQ(ierr);
    advect->inflowState = -2.0;
    ierr = PetscOptionsRealArray("-advect_inflow","Inflow state","",&advect->inflowState,&dof,PETSC_NULL);CHKERRQ(ierr);
  }
  ierr = PetscOptionsTail();CHKERRQ(ierr);
  phys->maxspeed = Norm2(advect->wind);
  PetscFunctionReturn(0);
}

/******************* Shallow Water ********************/
typedef struct {
  PetscReal gravity;
  PetscReal boundaryHeight;
  struct {
    PetscInt Height;
    PetscInt Speed;
    PetscInt Energy;
  } monitor;
} Physics_SW;
typedef struct {
  PetscScalar vals[0];
  PetscScalar h;
  PetscScalar uh[DIM];
} SWNode;

#undef __FUNCT__
#define __FUNCT__ "SWFlux"
/*
 * h_t + div(uh) = 0
 * (uh)_t + div (u\otimes uh + g h^2 / 2 I) = 0
 *
 * */
static PetscErrorCode SWFlux(Physics phys,const PetscReal *n,const SWNode *x,SWNode *f)
{
  Physics_SW *sw = (Physics_SW*)phys->data;
  PetscScalar uhn,u[DIM];
  PetscInt i;

  PetscFunctionBegin;
  Scale2(1./x->h,x->uh,u);
  uhn = Dot2(x->uh,n);
  f->h = uhn;
  for (i=0; i<DIM; i++) f->uh[i] = u[i] * uhn + sw->gravity * PetscSqr(x->h) * n[i];
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsBoundary_SW_Wall"
static PetscErrorCode PhysicsBoundary_SW_Wall(Physics phys, const PetscReal *n, const PetscScalar *xI, PetscScalar *xG)
{
  PetscFunctionBegin;
  xG[0] = xI[0];
  xG[1] = -xI[1];
  xG[2] = -xI[2];
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsRiemann_SW"
static PetscErrorCode PhysicsRiemann_SW(Physics phys, const PetscReal *n, const PetscScalar *xL, const PetscScalar *xR, PetscScalar *flux)
{
  Physics_SW *sw = (Physics_SW*)phys->data;
  PetscReal c,speed;
  const SWNode *uL = (const SWNode*)xL,*uR = (const SWNode*)xR;
  SWNode fL,fR;
  PetscInt i;

  PetscFunctionBegin;
  if (uL->h < 0 || uR->h < 0) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_ARG_OUTOFRANGE,"Reconstructed thickness is negative");
  SWFlux(phys,n,uL,&fL);
  SWFlux(phys,n,uR,&fR);
  c = PetscSqrtScalar(sw->gravity*PetscMax(uL->h,uR->h)); /* gravity wave speed */
  speed = PetscMax(PetscAbsScalar(Dot2(uL->uh,n)/uL->h),PetscAbsScalar(Dot2(uR->uh,n)/uR->h)) / Norm2(n) + c;
  for (i=0; i<1+DIM; i++) flux[i] = 0.5*(fL.vals[i] + fR.vals[i]) + 0.5*speed*(xL[i] - xR[i]);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsSolution_SW"
static PetscErrorCode PhysicsSolution_SW(User user,PetscReal time,const PetscReal *x,PetscScalar *u)
{
  //Physics_SW *sw = (Physics_SW*)user->physics->data;
  PetscReal dx[2],r,sigma;

  PetscFunctionBegin;
  if (time != 0.0) SETERRQ1(user->comm,PETSC_ERR_SUP,"No solution known for time %G",time);
  dx[0] = x[0] - 1.5;
  dx[1] = x[1] - 1.0;
  r = Norm2(dx);
  sigma = 0.5;
  u[0] = 1 + 0.1*PetscExpScalar(-PetscSqr(r)/(2*PetscSqr(sigma)));
  u[1] = 0.0;
  u[2] = 0.0;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsFunctional_SW"
static PetscErrorCode PhysicsFunctional_SW(Physics phys,const PetscScalar *xx,PetscReal *f)
{
  Physics_SW *sw = (Physics_SW*)phys->data;
  const SWNode *x = (const SWNode*)xx;
  PetscScalar u[2];
  PetscReal h;

  PetscFunctionBegin;
  h = PetscRealPart(x->h);
  f[sw->monitor.Height] = h;
  Scale2(1./x->h,x->uh,u);
  f[sw->monitor.Speed] = Norm2(u) + PetscSqrtReal(sw->gravity*h);
  f[sw->monitor.Energy] = 0.5*(Dot2(x->uh,u) + sw->gravity*PetscSqr(h));
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsCreate_SW"
static PetscErrorCode PhysicsCreate_SW(User user,Physics phys)
{
  const PetscInt wallids[] = {100,101,200,300};
  Physics_SW *sw;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = PhysicsBoundaryRegister(phys,"wall",PhysicsBoundary_SW_Wall,ALEN(wallids),wallids);CHKERRQ(ierr);
  phys->dof = 1+DIM;
  phys->riemann = PhysicsRiemann_SW;
  phys->solution = PhysicsSolution_SW;
  ierr = PetscNew(Physics_SW,&phys->data);CHKERRQ(ierr);
  sw = phys->data;
  ierr = PetscOptionsHead("SW options");CHKERRQ(ierr);
  {
    sw->gravity = 1.0;
    ierr = PetscOptionsReal("-sw_gravity","Gravitational constant","",sw->gravity,&sw->gravity,PETSC_NULL);CHKERRQ(ierr);
  }
  ierr = PetscOptionsTail();CHKERRQ(ierr);
  phys->maxspeed = PetscSqrtReal(2.0*sw->gravity); /* Mach 1 for depth of 2 */
  phys->monitor = PhysicsFunctional_SW;
  ierr = PhysicsFunctionalRegister(phys,"Height",&sw->monitor.Height);CHKERRQ(ierr);
  ierr = PhysicsFunctionalRegister(phys,"Speed",&sw->monitor.Speed);CHKERRQ(ierr);
  ierr = PhysicsFunctionalRegister(phys,"Energy",&sw->monitor.Energy);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "ConstructGhostCells"
PetscErrorCode ConstructGhostCells(DM *dmGhosted, User user)
{
  DM                 dm = *dmGhosted, gdm;
  PetscSection       coordSection, newCoordSection;
  Vec                coordinates;
  const char        *name = "Face Sets";
  IS                 idIS;
  const PetscInt    *ids;
  PetscInt          *newpoints;
  PetscSF            sfPoint, gsfPoint;
  const PetscInt    *leafLocal;
  const PetscSFNode *leafRemote;
  PetscInt           dim, depth, d, maxConeSize, maxSupportSize, numLabels, l;
  PetscInt           numFS, fs, pStart, pEnd, p, cStart, cEnd, c, ghostCell, vStart, vEnd, v;
  PetscMPIInt        rank;
  PetscErrorCode     ierr;

  PetscFunctionBegin;
  ierr = DMCreate(((PetscObject) dm)->comm, &gdm);CHKERRQ(ierr);
  ierr = DMSetType(gdm, DMCOMPLEX);CHKERRQ(ierr);
  ierr = DMComplexGetDimension(dm, &dim);CHKERRQ(ierr);
  ierr = DMComplexSetDimension(gdm, dim);CHKERRQ(ierr);

  ierr = DMComplexGetLabelIdIS(dm, name, &idIS);CHKERRQ(ierr);
  ierr = ISGetLocalSize(idIS, &numFS);CHKERRQ(ierr);
  ierr = ISGetIndices(idIS, &ids);CHKERRQ(ierr);
  user->numGhostCells = 0;
  for(fs = 0; fs < numFS; ++fs) {
    PetscInt numBdFaces;

    ierr = DMComplexGetStratumSize(dm, name, ids[fs], &numBdFaces);CHKERRQ(ierr);
    user->numGhostCells += numBdFaces;
  }
  ierr = DMComplexGetChart(dm, &pStart, &pEnd);CHKERRQ(ierr);
  pEnd += user->numGhostCells;
  ierr = DMComplexSetChart(gdm, pStart, pEnd);CHKERRQ(ierr);
  /* Set cone and support sizes */
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  user->cEndInterior = cEnd;
  for(c = cStart; c < cEnd; ++c) {
    PetscInt size;

    ierr = DMComplexGetConeSize(dm, c, &size);CHKERRQ(ierr);
    ierr = DMComplexSetConeSize(gdm, c, size);CHKERRQ(ierr);
  }
  for(c = cEnd; c < cEnd+user->numGhostCells; ++c) {
    ierr = DMComplexSetConeSize(gdm, c, 1);CHKERRQ(ierr);
  }
  ierr = DMComplexGetDepth(dm, &depth);CHKERRQ(ierr);
  for(d = 0; d < depth; ++d) {
    ierr = DMComplexGetDepthStratum(dm, d, &pStart, &pEnd);CHKERRQ(ierr);
    for(p = pStart; p < pEnd; ++p) {
      PetscInt newp = p+user->numGhostCells;
      PetscInt size;

      ierr = DMComplexGetConeSize(dm, p, &size);CHKERRQ(ierr);
      ierr = DMComplexSetConeSize(gdm, newp, size);CHKERRQ(ierr);
      ierr = DMComplexGetSupportSize(dm, p, &size);CHKERRQ(ierr);
      ierr = DMComplexSetSupportSize(gdm, newp, size);CHKERRQ(ierr);
    }
  }
  for(fs = 0; fs < numFS; ++fs) {
    IS              faceIS;
    const PetscInt *faces;
    PetscInt        numFaces, f;

    ierr = DMComplexGetStratumIS(dm, name, ids[fs], &faceIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(faceIS, &numFaces);CHKERRQ(ierr);
    ierr = ISGetIndices(faceIS, &faces);CHKERRQ(ierr);
    for(f = 0; f < numFaces; ++f) {
      PetscInt size;

      ierr = DMComplexGetSupportSize(dm, faces[f], &size);CHKERRQ(ierr);
      if (size != 1) SETERRQ2(((PetscObject) dm)->comm, PETSC_ERR_ARG_WRONG, "DM has boundary face %d with %d support cells", faces[f], size);
      ierr = DMComplexSetSupportSize(gdm, faces[f]+user->numGhostCells, 2);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(faceIS, &faces);CHKERRQ(ierr);
    ierr = ISDestroy(&faceIS);CHKERRQ(ierr);
  }
  ierr = DMSetUp(gdm);CHKERRQ(ierr);
  /* Set cones and supports, may have to orient supports here */
  ierr = DMComplexGetMaxSizes(dm, &maxConeSize, &maxSupportSize);CHKERRQ(ierr);
  ierr = PetscMalloc(PetscMax(maxConeSize, maxSupportSize) * sizeof(PetscInt), &newpoints);CHKERRQ(ierr);
  ierr = DMComplexGetChart(dm, &pStart, &pEnd);CHKERRQ(ierr);
  for(p = pStart; p < pEnd; ++p) {
    const PetscInt *points, *orientations;
    PetscInt        size, i, newp = p >= cEnd ? p+user->numGhostCells : p;

    ierr = DMComplexGetConeSize(dm, p, &size);CHKERRQ(ierr);
    ierr = DMComplexGetCone(dm, p, &points);CHKERRQ(ierr);
    ierr = DMComplexGetConeOrientation(dm, p, &orientations);CHKERRQ(ierr);
    for(i = 0; i < size; ++i) {
      newpoints[i] = points[i] >= cEnd ? points[i]+user->numGhostCells : points[i];
    }
    ierr = DMComplexSetCone(gdm, newp, newpoints);CHKERRQ(ierr);
    ierr = DMComplexSetConeOrientation(gdm, newp, orientations);CHKERRQ(ierr);
    ierr = DMComplexGetSupportSize(dm, p, &size);CHKERRQ(ierr);
    ierr = DMComplexGetSupport(dm, p, &points);CHKERRQ(ierr);
    for(i = 0; i < size; ++i) {
      newpoints[i] = points[i] >= cEnd ? points[i]+user->numGhostCells : points[i];
    }
    ierr = DMComplexSetSupport(gdm, newp, newpoints);CHKERRQ(ierr);
  }
  ierr = PetscFree(newpoints);CHKERRQ(ierr);
  ghostCell = cEnd;
  for(fs = 0; fs < numFS; ++fs) {
    IS              faceIS;
    const PetscInt *faces;
    PetscInt        numFaces, f;

    ierr = DMComplexGetStratumIS(dm, name, ids[fs], &faceIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(faceIS, &numFaces);CHKERRQ(ierr);
    ierr = ISGetIndices(faceIS, &faces);CHKERRQ(ierr);
    for(f = 0; f < numFaces; ++f, ++ghostCell) {
      PetscInt newFace = faces[f] + user->numGhostCells;

      ierr = DMComplexSetCone(gdm, ghostCell, &newFace);CHKERRQ(ierr);
      ierr = DMComplexInsertSupport(gdm, newFace, 1, ghostCell);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(faceIS, &faces);CHKERRQ(ierr);
    ierr = ISDestroy(&faceIS);CHKERRQ(ierr);
  }
  ierr = ISRestoreIndices(idIS, &ids);CHKERRQ(ierr);
  ierr = ISDestroy(&idIS);CHKERRQ(ierr);
  ierr = DMComplexStratify(gdm);CHKERRQ(ierr);
  /* Convert coordinates */
  ierr = DMComplexGetDepthStratum(dm, 0, &vStart, &vEnd);CHKERRQ(ierr);
  ierr = DMComplexGetCoordinateSection(dm, &coordSection);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &newCoordSection);CHKERRQ(ierr);
  ierr = PetscSectionSetNumFields(newCoordSection, 1);CHKERRQ(ierr);
  ierr = PetscSectionSetFieldComponents(newCoordSection, 0, dim);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(newCoordSection, vStart+user->numGhostCells, vEnd+user->numGhostCells);CHKERRQ(ierr);
  for(v = vStart; v < vEnd; ++v) {
    ierr = PetscSectionSetDof(newCoordSection, v+user->numGhostCells, dim);CHKERRQ(ierr);
    ierr = PetscSectionSetFieldDof(newCoordSection, v+user->numGhostCells, 0, dim);CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(newCoordSection);CHKERRQ(ierr);
  ierr = DMComplexSetCoordinateSection(gdm, newCoordSection);CHKERRQ(ierr);
  ierr = DMGetCoordinatesLocal(dm, &coordinates);CHKERRQ(ierr);
  ierr = DMSetCoordinatesLocal(gdm, coordinates);CHKERRQ(ierr);
  /* Convert labels */
  ierr = DMComplexGetNumLabels(dm, &numLabels);CHKERRQ(ierr);
  for(l = 0; l < numLabels; ++l) {
    const char *lname;
    PetscBool   isDepth;

    ierr = DMComplexGetLabelName(dm, l, &lname);CHKERRQ(ierr);
    ierr = PetscStrcmp(lname, "depth", &isDepth);CHKERRQ(ierr);
    if (isDepth) continue;
    ierr = DMComplexGetLabelIdIS(dm, lname, &idIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(idIS, &numFS);CHKERRQ(ierr);
    ierr = ISGetIndices(idIS, &ids);CHKERRQ(ierr);
    for(fs = 0; fs < numFS; ++fs) {
      IS              pointIS;
      const PetscInt *points;
      PetscInt        numPoints;

      ierr = DMComplexGetStratumIS(dm, lname, ids[fs], &pointIS);CHKERRQ(ierr);
      ierr = ISGetLocalSize(pointIS, &numPoints);CHKERRQ(ierr);
      ierr = ISGetIndices(pointIS, &points);CHKERRQ(ierr);
      for(p = 0; p < numPoints; ++p) {
        PetscInt newpoint = points[p] >= cEnd ? points[p]+user->numGhostCells : points[p];

        ierr = DMComplexSetLabelValue(gdm, lname, newpoint, ids[fs]);CHKERRQ(ierr);
      }
      ierr = ISRestoreIndices(pointIS, &points);CHKERRQ(ierr);
      ierr = ISDestroy(&pointIS);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(idIS, &ids);CHKERRQ(ierr);
    ierr = ISDestroy(&idIS);CHKERRQ(ierr);
  }
  /* Convert pointSF */
  const PetscSFNode *remotePoints;
  PetscSFNode       *gremotePoints;
  const PetscInt    *localPoints;
  PetscInt          *glocalPoints,*newLocation,*newRemoteLocation;
  PetscInt           numRoots, numLeaves;
  PetscMPIInt        numProcs;

  ierr = MPI_Comm_size(((PetscObject) dm)->comm, &numProcs);CHKERRQ(ierr);
  ierr = DMGetPointSF(dm, &sfPoint);CHKERRQ(ierr);
  ierr = DMGetPointSF(gdm, &gsfPoint);CHKERRQ(ierr);
  ierr = DMComplexGetChart(dm,&pStart,&pEnd);CHKERRQ(ierr);
  ierr = PetscSFGetGraph(sfPoint, &numRoots, &numLeaves, &localPoints, &remotePoints);CHKERRQ(ierr);
  if (numRoots >= 0) {
    ierr = PetscMalloc2(numRoots,PetscInt,&newLocation,pEnd-pStart,PetscInt,&newRemoteLocation);CHKERRQ(ierr);
    for (l=0; l<numRoots; l++) newLocation[l] = l + (l >= cEnd ? user->numGhostCells : 0);
    ierr = PetscSFBcastBegin(sfPoint, MPIU_INT, newLocation, newRemoteLocation);CHKERRQ(ierr);
    ierr = PetscSFBcastEnd(sfPoint, MPIU_INT, newLocation, newRemoteLocation);CHKERRQ(ierr);
    ierr = PetscMalloc(numLeaves * sizeof(PetscInt),    &glocalPoints);CHKERRQ(ierr);
    ierr = PetscMalloc(numLeaves * sizeof(PetscSFNode), &gremotePoints);CHKERRQ(ierr);
    for(l = 0; l < numLeaves; ++l) {
      glocalPoints[l]        = localPoints[l] >= cEnd ? localPoints[l] + user->numGhostCells : localPoints[l];
      gremotePoints[l].rank  = remotePoints[l].rank;
      gremotePoints[l].index = newRemoteLocation[localPoints[l]];
    }
    ierr = PetscFree2(newLocation,newRemoteLocation);CHKERRQ(ierr);
    ierr = PetscSFSetGraph(gsfPoint, numRoots+user->numGhostCells, numLeaves, glocalPoints, PETSC_OWN_POINTER, gremotePoints, PETSC_OWN_POINTER);CHKERRQ(ierr);
  }
  /* Make label for VTK output and ghost cells */
  ierr = MPI_Comm_rank(((PetscObject) dm)->comm, &rank);CHKERRQ(ierr);
  ierr = PetscSFGetGraph(sfPoint, PETSC_NULL, &numLeaves, &leafLocal, &leafRemote);CHKERRQ(ierr);
  ierr = DMComplexCreateLabel(gdm, "vtk");CHKERRQ(ierr);
  ierr = DMComplexCreateLabel(gdm, "ghost");CHKERRQ(ierr);
  for(l = 0, c = cStart; l < numLeaves && c < cEnd; ++l, ++c) {
    for(; c < leafLocal[l] && c < cEnd; ++c) {
      ierr = DMComplexSetLabelValue(gdm, "vtk", c, 1);CHKERRQ(ierr);
    }
    if (leafLocal[l] >= cEnd) break;
    if (leafRemote[l].rank == rank) {
      ierr = DMComplexSetLabelValue(gdm, "vtk", c, 1);CHKERRQ(ierr);
    } else {
      ierr = DMComplexSetLabelValue(gdm, "ghost", c, 2);CHKERRQ(ierr);
    }
  }
  for(; c < cEnd; ++c) {
    ierr = DMComplexSetLabelValue(gdm, "vtk", c, 1);CHKERRQ(ierr);
  }
#if 0
  ierr = PetscViewerASCIISynchronizedAllow(PETSC_VIEWER_STDOUT_WORLD, PETSC_TRUE);CHKERRQ(ierr);
  ierr = DMComplexViewLabel_Ascii(gdm, "vtk", PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
  ierr = PetscViewerFlush(PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
#endif
  /* Make a label for ghost faces */
  PetscInt fStart, fEnd, f;

  ierr = DMComplexGetHeightStratum(gdm, 1, &fStart, &fEnd);CHKERRQ(ierr);
  for(f = fStart; f < fEnd; ++f) {
    PetscInt numCells;

    ierr = DMComplexGetSupportSize(gdm, f, &numCells);CHKERRQ(ierr);
    if (numCells < 2) {
      ierr = DMComplexSetLabelValue(gdm, "ghost", f, 1);CHKERRQ(ierr);
    } else {
      const PetscInt *cells;
      PetscInt        vA, vB;

      ierr = DMComplexGetSupport(gdm, f, &cells);CHKERRQ(ierr);
      ierr = DMComplexGetLabelValue(gdm, "vtk", cells[0], &vA);CHKERRQ(ierr);
      ierr = DMComplexGetLabelValue(gdm, "vtk", cells[1], &vB);CHKERRQ(ierr);
      if (!vA && !vB) {ierr = DMComplexSetLabelValue(gdm, "ghost", f, 1);CHKERRQ(ierr);}
    }
  }
#if 0
  ierr = PetscViewerASCIISynchronizedAllow(PETSC_VIEWER_STDOUT_WORLD, PETSC_TRUE);CHKERRQ(ierr);
  ierr = DMComplexViewLabel_Ascii(gdm, "ghost", PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
  ierr = PetscViewerFlush(PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);
#endif

  ierr = DMSetFromOptions(gdm);CHKERRQ(ierr);
  ierr = DMDestroy(dmGhosted);CHKERRQ(ierr);
  *dmGhosted = gdm;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SplitFaces"
PetscErrorCode SplitFaces(DM *dmSplit, User user)
{
  PetscFunctionBegin;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PseudoInverse"
/* Overwrites A */
static PetscErrorCode PseudoInverse(PetscInt m,PetscInt n,PetscScalar *A,PetscScalar *Ainv,PetscScalar *tau,PetscScalar *work)
{
  PetscBool debug = PETSC_FALSE;
  PetscErrorCode ierr;
  PetscBLASInt M,N,K,lda,ldb,ldwork,info;
  PetscScalar *R,*Q,*Aback,Alpha;

  PetscFunctionBegin;
  if (debug) {
    ierr = PetscMalloc(m*n*sizeof(PetscScalar),&Aback);CHKERRQ(ierr);
    ierr = PetscMemcpy(Aback,A,m*n*sizeof(PetscScalar));CHKERRQ(ierr);
  }

  M = PetscBLASIntCast(m);
  N = PetscBLASIntCast(n);
  lda = M;
  ldwork = M*N;
  ierr = PetscFPTrapPush(PETSC_FP_TRAP_OFF);CHKERRQ(ierr);
  LAPACKgeqrf_(&M,&N,A,&lda,tau,work,&ldwork,&info);
  ierr = PetscFPTrapPop();CHKERRQ(ierr);
  if (info) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_LIB,"xGEQRF error");
  R = A; /* Upper triangular part of A now contains R, the rest contains the elementary reflectors */

  /* Extract an explicit representation of Q */
  Q = Ainv;
  ierr = PetscMemcpy(Q,A,m*n*sizeof(PetscScalar));CHKERRQ(ierr);
  K = N;                        /* full rank */
  LAPACKungqr_(&M,&N,&K,Q,&lda,tau,work,&ldwork,&info);
  if (info) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_LIB,"xORGQR/xUNGQR error");

  /* Compute A^{-T} = (R^{-1} Q^T)^T = Q R^{-T} */
  Alpha = 1.0;
  ldb = lda;
  BLAStrsm_("Right","Upper","ConjugateTranspose","NotUnitTriangular",&M,&N,&Alpha,R,&lda,Q,&ldb);
  /* Ainv is Q, overwritten with inverse */

  if (debug) {                      /* Check that pseudo-inverse worked */
    PetscScalar Beta = 0.0;
    PetscInt ldc;
    K = N;
    ldc = N;
    BLASgemm_("ConjugateTranspose","Normal",&N,&K,&M,&Alpha,Ainv,&lda,Aback,&ldb,&Beta,work,&ldc);
    ierr = PetscScalarView(n*n,work,PETSC_VIEWER_STDOUT_SELF);CHKERRQ(ierr);
    ierr = PetscFree(Aback);CHKERRQ(ierr);
  }
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "BuildLeastSquares"
/* Build least squares gradient reconstruction operators */
static PetscErrorCode BuildLeastSquares(DM dm,PetscInt cEndInterior,DM dmFace,PetscScalar *fgeom,DM dmCell,PetscScalar *cgeom)
{
  PetscErrorCode ierr;
  PetscInt c,cStart,cEnd,maxNumFaces;
  PetscScalar *B,*Binv,*work,*tau,**gref;

  PetscFunctionBegin;
  ierr = DMComplexGetHeightStratum(dm,0,&cStart,&cEnd);CHKERRQ(ierr);
  ierr = DMComplexGetMaxSizes(dm,&maxNumFaces,PETSC_NULL);CHKERRQ(ierr);
  ierr = PetscMalloc5(maxNumFaces*DIM,PetscScalar,&B,maxNumFaces*DIM,PetscScalar,&Binv,maxNumFaces*DIM,PetscScalar,&work,maxNumFaces,PetscScalar,&tau,maxNumFaces,PetscScalar*,&gref);CHKERRQ(ierr);
  for (c=cStart; c<cEndInterior; c++) {
    const PetscInt *faces;
    PetscInt numFaces,f,i,j;
    const CellGeom *cg;
    ierr = DMComplexGetConeSize(dm,c,&numFaces);CHKERRQ(ierr);
    if (numFaces < DIM) SETERRQ2(PETSC_COMM_SELF,PETSC_ERR_ARG_INCOMP,"Cell %D has only %D faces, not enough for gradient reconstruction",c,numFaces);
    ierr = DMComplexGetCone(dm,c,&faces);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmCell,c,cgeom,&cg);CHKERRQ(ierr);
    for (f=0; f<numFaces; f++) {
      const PetscInt *fcells;
      ierr = DMComplexGetSupport(dm,faces[f],&fcells);CHKERRQ(ierr);
      gref[f] = PETSC_NULL;
      for (i=0; i<2; i++) {
        FaceGeom *fg;
        const CellGeom *cg1;
        if (fcells[i] == c) continue;
        ierr = DMComplexPointLocalRef(dmFace,faces[f],fgeom,&fg);CHKERRQ(ierr);
        ierr = DMComplexPointLocalRead(dmCell,fcells[i],cgeom,&cg1);CHKERRQ(ierr);
        for (j=0; j<DIM; j++) B[j*numFaces+f] = cg1->centroid[j] - cg->centroid[j];
        gref[f] = fg->grad[(i+1)%2];  /* Gradient reconstruction term will go here */
      }
      if (!gref[f]) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_PLIB,"Connectivity corrrupt");
    }

    /* Overwrites B with garbage, returns Binv in row-major format */
    ierr = PseudoInverse(numFaces,DIM,B,Binv,tau,work);CHKERRQ(ierr);
    for (f=0; f<numFaces; f++) {
      for (j=0; j<DIM; j++) {
        gref[f][j] = Binv[j*numFaces+f];
      }
    }

#if 1
    if (0) {
      PetscReal grad[2] = {0,0};
      for (f=0; f<numFaces; f++) {
        const PetscInt *fcells;
        const CellGeom *cg1;
        const FaceGeom *fg;
        ierr = DMComplexGetSupport(dm,faces[f],&fcells);CHKERRQ(ierr);
        ierr = DMComplexPointLocalRead(dmFace,faces[f],fgeom,&fg);CHKERRQ(ierr);
        for (i=0; i<2; i++) {
          if (fcells[i] == c) continue;
          ierr = DMComplexPointLocalRead(dmCell,fcells[i],cgeom,&cg1);CHKERRQ(ierr);
          PetscScalar du = cg1->centroid[0] + 3*cg1->centroid[1] - (cg->centroid[0] + 3*cg->centroid[1]);
          grad[0] += fg->grad[!i][0] * du;
          grad[1] += fg->grad[!i][1] * du;
        }
      }
      printf("cell[%d] grad (%g,%g)\n",c,grad[0],grad[1]);
    }
#endif
  }
  ierr = PetscFree5(B,Binv,work,tau,gref);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "ConstructGeometry"
/* Set up face data and cell data */
PetscErrorCode ConstructGeometry(DM dm, Vec *facegeom, Vec *cellgeom, User user)
{
  DM             dmFace, dmCell;
  PetscSection   sectionFace, sectionCell;
  PetscSection   coordSection;
  Vec            coordinates;
  PetscReal      minradius;
  PetscScalar   *fgeom, *cgeom;
  PetscInt       dim, cStart, cEnd, c, fStart, fEnd, f;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMComplexGetDimension(dm, &dim);CHKERRQ(ierr);
  ierr = DMComplexGetCoordinateSection(dm, &coordSection);CHKERRQ(ierr);
  ierr = DMGetCoordinatesLocal(dm, &coordinates);CHKERRQ(ierr);

  /* Make cell centroids and volumes */
  ierr = DMComplexClone(dm, &dmCell);CHKERRQ(ierr);
  ++coordSection->refcnt;
  ierr = DMComplexSetCoordinateSection(dmCell, coordSection);CHKERRQ(ierr);
  ierr = DMSetCoordinatesLocal(dmCell, coordinates);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &sectionCell);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(sectionCell, cStart, cEnd);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    ierr = PetscSectionSetDof(sectionCell, c, sizeof(CellGeom)/sizeof(PetscScalar));CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(sectionCell);CHKERRQ(ierr);
  ierr = DMSetDefaultSection(dmCell, sectionCell);CHKERRQ(ierr);

  ierr = DMCreateLocalVector(dmCell, cellgeom);CHKERRQ(ierr);
  ierr = VecGetArray(*cellgeom, &cgeom);CHKERRQ(ierr);
  for(c = cStart; c < user->cEndInterior; ++c) {
    const PetscScalar *coords = PETSC_NULL;
    PetscInt           coordSize, numCorners, p;
    PetscScalar        sx = 0, sy = 0;
    CellGeom          *cg;

    ierr = DMComplexVecGetClosure(dm, coordSection, coordinates, c, &coordSize, &coords);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRef(dmCell, c, cgeom, &cg);CHKERRQ(ierr);
    ierr = PetscMemzero(cg,sizeof(*cg));CHKERRQ(ierr);
    numCorners = coordSize/dim;
    for(p = 0; p < numCorners; ++p) {
      const PetscScalar *x = coords+p*dim, *y = coords+((p+1)%numCorners)*dim;
      const PetscScalar cross = x[0]*y[1] - x[1]*y[0];
      cg->volume += 0.5*cross;
      sx += (x[0] + y[0])*cross;
      sy += (x[1] + y[1])*cross;
    }
    cg->centroid[0] = sx / (6*cg->volume);
    cg->centroid[1] = sy / (6*cg->volume);
    cg->volume = PetscAbsScalar(cg->volume);
    ierr = DMComplexVecRestoreClosure(dm, coordSection, coordinates, c, &coordSize, &coords);CHKERRQ(ierr);
  }

  /* Make normals and fill in ghost centroids */
  ierr = DMComplexClone(dm, &dmFace);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &sectionFace);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 1, &fStart, &fEnd);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(sectionFace, fStart, fEnd);CHKERRQ(ierr);
  for(f = fStart; f < fEnd; ++f) {
    ierr = PetscSectionSetDof(sectionFace, f, sizeof(FaceGeom)/sizeof(PetscScalar));CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(sectionFace);CHKERRQ(ierr);
  ierr = DMSetDefaultSection(dmFace, sectionFace);CHKERRQ(ierr);
  ierr = DMCreateLocalVector(dmFace, facegeom);CHKERRQ(ierr);
  ierr = VecGetArray(*facegeom, &fgeom);CHKERRQ(ierr);
  minradius = PETSC_MAX_REAL;
  for(f = fStart; f < fEnd; ++f) {
    const PetscScalar *coords = PETSC_NULL;
    const PetscInt    *cells;
    PetscInt           ghost,i,coordSize;
    PetscScalar        v[2];
    FaceGeom          *fg;
    CellGeom          *cL,*cR;

    ierr = DMComplexGetLabelValue(dm, "ghost", f, &ghost);CHKERRQ(ierr);
    if (ghost >= 0) continue;
    ierr = DMComplexVecGetClosure(dm, coordSection, coordinates, f, &coordSize, &coords);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRef(dmFace, f, fgeom, &fg);CHKERRQ(ierr);
    /* Only support edges right now */
    if (coordSize != dim*2) SETERRQ(((PetscObject) dm)->comm, PETSC_ERR_SUP, "We only support edges right now");
    fg->centroid[0] = 0.5*(coords[0] + coords[dim]);
    fg->centroid[1] = 0.5*(coords[1] + coords[dim+1]);
    fg->normal[0] =  (coords[1] - coords[dim+1]);
    fg->normal[1] = -(coords[0] - coords[dim+0]);
    ierr = DMComplexVecRestoreClosure(dm, coordSection, coordinates, f, &coordSize, &coords);CHKERRQ(ierr);
    ierr = DMComplexGetSupport(dm, f, &cells);CHKERRQ(ierr);
    /* Reflect ghost centroid across plane of face */
    for (i=0; i<2; i++) {
      if (cells[i] >= user->cEndInterior) {
        const CellGeom *ci;
        CellGeom       *cg;
        PetscScalar    c2f[2],a;
        ierr = DMComplexPointLocalRead(dmCell, cells[(i+1)%2], cgeom, &ci);CHKERRQ(ierr);
        Waxpy2(-1,ci->centroid,fg->centroid,c2f); /* cell to face centroid */
        a = Dot2(c2f,fg->normal)/Dot2(fg->normal,fg->normal);
        ierr = DMComplexPointLocalRef(dmCell, cells[i], cgeom, &cg);CHKERRQ(ierr);
        Waxpy2(2*a,fg->normal,ci->centroid,cg->centroid);
        cg->volume = ci->volume;
      }
    }
    /* Flip face orientation if necessary to match ordering in support */
    ierr = DMComplexPointLocalRead(dmCell, cells[0], cgeom, &cL);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmCell, cells[1], cgeom, &cR);CHKERRQ(ierr);
    Waxpy2(-1,cL->centroid,cR->centroid,v);
    if (Dot2(fg->normal, v) < 0) {
      fg->normal[0] = -fg->normal[0];
      fg->normal[1] = -fg->normal[1];
    }
    if (Dot2(fg->normal,v) <= 0) SETERRQ(PETSC_COMM_SELF,PETSC_ERR_PLIB,"Face direction could not be fixed");
    /* Update minimum radius */
    Waxpy2(-1,fg->centroid,cL->centroid,v);
    minradius = PetscMin(minradius,Norm2(v));
    Waxpy2(-1,fg->centroid,cR->centroid,v);
    minradius = PetscMin(minradius,Norm2(v));
  }

  if (user->reconstruct) {
    PetscSection sectionGrad;
    ierr = BuildLeastSquares(dm,user->cEndInterior,dmFace,fgeom,dmCell,cgeom);CHKERRQ(ierr);
    ierr = DMComplexClone(dm,&user->dmGrad);CHKERRQ(ierr);
    ierr = PetscSectionCreate(((PetscObject)dm)->comm,&sectionGrad);CHKERRQ(ierr);
    ierr = PetscSectionSetChart(sectionGrad,cStart,cEnd);CHKERRQ(ierr);
    for (c=cStart; c<cEnd; c++) {
      ierr = PetscSectionSetDof(sectionGrad,c,user->physics->dof*DIM);CHKERRQ(ierr);
    }
    ierr = PetscSectionSetUp(sectionGrad);CHKERRQ(ierr);
    ierr = DMSetDefaultSection(user->dmGrad,sectionGrad);CHKERRQ(ierr);
  }
  ierr = VecRestoreArray(*facegeom, &fgeom);CHKERRQ(ierr);
  ierr = VecRestoreArray(*cellgeom, &cgeom);CHKERRQ(ierr);
  ierr = MPI_Allreduce(&minradius, &user->minradius, 1, MPIU_SCALAR, MPI_MIN, ((PetscObject) dm)->comm);CHKERRQ(ierr);
  ierr = DMDestroy(&dmCell);CHKERRQ(ierr);
  ierr = DMDestroy(&dmFace);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "CreatePartitionVec"
PetscErrorCode CreatePartitionVec(DM dm, DM *dmCell, Vec *partition)
{
  PetscSF        sfPoint;
  PetscSection   coordSection;
  Vec            coordinates;
  PetscSection   sectionCell;
  PetscScalar   *part;
  PetscInt       cStart, cEnd, c;
  PetscMPIInt    rank;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMComplexGetCoordinateSection(dm, &coordSection);CHKERRQ(ierr);
  ierr = DMGetCoordinatesLocal(dm, &coordinates);CHKERRQ(ierr);
  ierr = DMComplexClone(dm, dmCell);CHKERRQ(ierr);
  ierr = DMGetPointSF(dm, &sfPoint);CHKERRQ(ierr);
  ierr = DMSetPointSF(*dmCell, sfPoint);CHKERRQ(ierr);
  ++coordSection->refcnt;
  ierr = DMComplexSetCoordinateSection(*dmCell, coordSection);CHKERRQ(ierr);
  ierr = DMSetCoordinatesLocal(*dmCell, coordinates);CHKERRQ(ierr);
  ierr = MPI_Comm_rank(((PetscObject) dm)->comm, &rank);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &sectionCell);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(*dmCell, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(sectionCell, cStart, cEnd);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    ierr = PetscSectionSetDof(sectionCell, c, 1);CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(sectionCell);CHKERRQ(ierr);
  ierr = DMSetDefaultSection(*dmCell, sectionCell);CHKERRQ(ierr);
  ierr = DMCreateLocalVector(*dmCell, partition);CHKERRQ(ierr);
  ierr = PetscObjectSetName((PetscObject)*partition, "partition");CHKERRQ(ierr);
  ierr = VecGetArray(*partition, &part);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    PetscScalar *p;

    ierr = DMComplexPointLocalRef(*dmCell, c, part, &p);CHKERRQ(ierr);
    p[0] = rank;
  }
  ierr = VecRestoreArray(*partition, &part);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SetUpLocalSpace"
PetscErrorCode SetUpLocalSpace(DM dm, User user)
{
  PetscSection   stateSection;
  PetscInt       dof = user->physics->dof, *cind, d, stateSize, cStart, cEnd, c;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &stateSection);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(stateSection, cStart, cEnd);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    ierr = PetscSectionSetDof(stateSection, c, dof);CHKERRQ(ierr);
#if 0
    {
      PetscInt val;
      ierr = DMComplexGetLabelValue(dm, "vtk", c, &val);CHKERRQ(ierr);
      if (val < 0) {ierr = PetscSectionSetConstraintDof(stateSection, c, dof);CHKERRQ(ierr);}
    }
#endif
  }
  for(c = user->cEndInterior; c < cEnd; ++c) {
    ierr = PetscSectionSetConstraintDof(stateSection, c, dof);CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(stateSection);CHKERRQ(ierr);
  ierr = PetscMalloc(dof * sizeof(PetscInt), &cind);CHKERRQ(ierr);
  for(d = 0; d < dof; ++d) cind[d] = d;
#if 0
  for(c = cStart; c < cEnd; ++c) {
    PetscInt val;

    ierr = DMComplexGetLabelValue(dm, "vtk", c, &val);CHKERRQ(ierr);
    if (val < 0) {ierr = PetscSectionSetConstraintIndices(stateSection, c, cind);CHKERRQ(ierr);}
  }
#endif
  for(c = user->cEndInterior; c < cEnd; ++c) {
    ierr = PetscSectionSetConstraintIndices(stateSection, c, cind);CHKERRQ(ierr);
  }
  ierr = PetscFree(cind);CHKERRQ(ierr);
  ierr = PetscSectionGetStorageSize(stateSection, &stateSize);CHKERRQ(ierr);
  ierr = DMSetDefaultSection(dm,stateSection);CHKERRQ(ierr);
  if (0) {                      /* Crazy that DMSetDefaultSection does not increment refct */
    ierr = PetscSectionDestroy(&stateSection);CHKERRQ(ierr);
  }
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SetUpBoundaries"
PetscErrorCode SetUpBoundaries(DM dm, User user)
{
  Physics phys = user->physics;
  PetscErrorCode ierr;
  BoundaryLink b;

  PetscFunctionBegin;
  ierr = PetscOptionsBegin(((PetscObject)dm)->comm,PETSC_NULL,"Boundary condition options","");CHKERRQ(ierr);
  for (b = phys->boundary; b; b=b->next) {
    char optname[512];
    PetscInt ids[512],len = 512;
    PetscBool flg;
    ierr = PetscSNPrintf(optname,sizeof optname,"-bc_%s",b->name);CHKERRQ(ierr);
    ierr = PetscMemzero(ids,sizeof(ids));CHKERRQ(ierr);
    ierr = PetscOptionsIntArray(optname,"List of boundary IDs","",ids,&len,&flg);CHKERRQ(ierr);
    if (flg) {
      /* TODO: check all IDs to make sure they exist in the mesh */
      ierr = PetscFree(b->ids);CHKERRQ(ierr);
      b->numids = len;
      ierr = PetscMalloc(len*sizeof(PetscInt),&b->ids);CHKERRQ(ierr);
      ierr = PetscMemcpy(b->ids,ids,len*sizeof(PetscInt));CHKERRQ(ierr);
    }
  }
  ierr = PetscOptionsEnd();CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsBoundaryRegister"
/* ids are just defaults, can be overridden at command line */
static PetscErrorCode PhysicsBoundaryRegister(Physics phys,const char *name,BoundaryFunction bcFunc,PetscInt numids,const PetscInt *ids)
{
  PetscErrorCode ierr;
  BoundaryLink link;

  PetscFunctionBegin;
  ierr = PetscNew(struct _n_BoundaryLink,&link);CHKERRQ(ierr);
  ierr = PetscStrallocpy(name,&link->name);CHKERRQ(ierr);
  link->numids = numids;
  ierr = PetscMalloc(numids*sizeof(PetscInt),&link->ids);CHKERRQ(ierr);
  ierr = PetscMemcpy(link->ids,ids,numids*sizeof(PetscInt));CHKERRQ(ierr);
  link->func = bcFunc;
  link->next = phys->boundary;
  phys->boundary = link;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "BoundaryLinkDestroy"
static PetscErrorCode BoundaryLinkDestroy(BoundaryLink *link)
{
  PetscErrorCode ierr;
  BoundaryLink l,next;

  PetscFunctionBegin;
  if (!link) PetscFunctionReturn(0);
  l = *link;
  *link = PETSC_NULL;
  for ( ; l; l=next) {
    next = l->next;
    ierr = PetscFree(l->ids);CHKERRQ(ierr);
    ierr = PetscFree(l->name);CHKERRQ(ierr);
    ierr = PetscFree(l);CHKERRQ(ierr);
  }
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "PhysicsBoundaryFind"
static PetscErrorCode PhysicsBoundaryFind(Physics phys,PetscInt id,BoundaryFunction *bcFunc)
{
  BoundaryLink link;
  PetscInt i;

  PetscFunctionBegin;
  *bcFunc = PETSC_NULL;
  for (link=phys->boundary; link; link=link->next) {
    for (i=0; i<link->numids; i++) {
      if (link->ids[i] == id) {
        *bcFunc = link->func;
        PetscFunctionReturn(0);
      }
    }
  }
  SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_USER,"Boundary ID %D not associated with any registered boundary condition",id);
  PetscFunctionReturn(0);
}
#undef __FUNCT__
#define __FUNCT__ "PhysicsFunctionalRegister"
static PetscErrorCode PhysicsFunctionalRegister(Physics phys,const char *name,PetscInt *offset)
{
  PetscErrorCode ierr;
  FunctionalLink link,*ptr;
  PetscInt lastoffset = -1;

  PetscFunctionBegin;
  for (ptr=&phys->functional; *ptr; ptr = &(*ptr)->next) lastoffset = (*ptr)->offset;
  ierr = PetscNew(struct _n_FunctionalLink,&link);CHKERRQ(ierr);
  ierr = PetscStrallocpy(name,&link->name);CHKERRQ(ierr);
  link->offset = lastoffset + 1;
  link->next = PETSC_NULL;
  *ptr = link;
  *offset = link->offset;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "FunctionalLinkDestroy"
static PetscErrorCode FunctionalLinkDestroy(FunctionalLink *link)
{
  PetscErrorCode ierr;
  FunctionalLink l,next;

  PetscFunctionBegin;
  if (!link) PetscFunctionReturn(0);
  l = *link;
  *link = PETSC_NULL;
  for ( ; l; l=next) {
    next = l->next;
    ierr = PetscFree(l->name);CHKERRQ(ierr);
    ierr = PetscFree(l);CHKERRQ(ierr);
  }
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SetInitialCondition"
PetscErrorCode SetInitialCondition(DM dm, Vec X, User user)
{
  DM                 dmCell;
  const PetscScalar  *cellgeom;
  PetscScalar        *x;
  PetscInt           cStart, cEnd, cEndInterior = user->cEndInterior, c;
  PetscErrorCode     ierr;

  PetscFunctionBegin;
  ierr = VecGetDM(user->cellgeom, &dmCell);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->cellgeom, &cellgeom);CHKERRQ(ierr);
  ierr = VecGetArray(X, &x);CHKERRQ(ierr);
  for(c = cStart; c < cEndInterior; ++c) {
    const CellGeom *cg;
    PetscScalar *xc;

    ierr = DMComplexPointLocalRead(dmCell,c,cellgeom,&cg);CHKERRQ(ierr);
    ierr = DMComplexPointGlobalRef(dm,c,x,&xc);CHKERRQ(ierr);
    if (xc) {ierr = (*user->physics->solution)(user,0.0,cg->centroid,xc);CHKERRQ(ierr);}
  }
  ierr = VecRestoreArrayRead(user->cellgeom, &cellgeom);CHKERRQ(ierr);
  ierr = VecRestoreArray(X, &x);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "ApplyBC"
static PetscErrorCode ApplyBC(DM dm, Vec locX, User user)
{
  Physics        phys = user->physics;
  const char     *name = "Face Sets";
  DM             dmFace;
  IS             idIS;
  const PetscInt *ids;
  PetscScalar    *x;
  const PetscScalar *facegeom;
  PetscInt       numFS, fs;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = VecGetDM(user->facegeom,&dmFace);CHKERRQ(ierr);
  ierr = DMComplexGetLabelIdIS(dm, name, &idIS);CHKERRQ(ierr);
  if (!idIS) PetscFunctionReturn(0);
  ierr = ISGetLocalSize(idIS, &numFS);CHKERRQ(ierr);
  ierr = ISGetIndices(idIS, &ids);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->facegeom, &facegeom);CHKERRQ(ierr);
  ierr = VecGetArray(locX, &x);CHKERRQ(ierr);
  for(fs = 0; fs < numFS; ++fs) {
    BoundaryFunction bcFunc;
    IS               faceIS;
    const PetscInt   *faces;
    PetscInt         numFaces, f;

    ierr = PhysicsBoundaryFind(phys,ids[fs],&bcFunc);CHKERRQ(ierr);
    ierr = DMComplexGetStratumIS(dm, name, ids[fs], &faceIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(faceIS, &numFaces);CHKERRQ(ierr);
    ierr = ISGetIndices(faceIS, &faces);CHKERRQ(ierr);
    for(f = 0; f < numFaces; ++f) {
      const PetscInt    face = faces[f], *cells;
      const PetscScalar *xI;
      PetscScalar       *xG;
      const FaceGeom    *fg;

      ierr = DMComplexPointLocalRead(dmFace, face, facegeom, &fg);CHKERRQ(ierr);
      ierr = DMComplexGetSupport(dm, face, &cells);CHKERRQ(ierr);
      ierr = DMComplexPointLocalRead(dm, cells[0], x, &xI);CHKERRQ(ierr);
      ierr = DMComplexPointLocalRef(dm, cells[1], x, &xG);CHKERRQ(ierr);
      ierr = (*bcFunc)(user->physics, fg->normal, xI, xG);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(faceIS, &faces);CHKERRQ(ierr);
    ierr = ISDestroy(&faceIS);CHKERRQ(ierr);
  }
  ierr = VecRestoreArray(locX, &x);CHKERRQ(ierr);
  ierr = VecRestoreArrayRead(user->facegeom,&facegeom);CHKERRQ(ierr);
  ierr = ISRestoreIndices(idIS, &ids);CHKERRQ(ierr);
  ierr = ISDestroy(&idIS);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "RHSFunctionLocal_Upwind"
static PetscErrorCode RHSFunctionLocal_Upwind(DM dm,DM dmFace,DM dmCell,Vec locX,Vec F,User user)
{
  Physics            phys = user->physics;
  PetscErrorCode ierr;
  const PetscScalar *facegeom, *cellgeom, *x;
  PetscScalar       *f;
  PetscInt           fStart, fEnd, face;

  PetscFunctionBegin;
  ierr = VecGetArrayRead(user->facegeom,&facegeom);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->cellgeom,&cellgeom);CHKERRQ(ierr);
  ierr = VecGetArrayRead(locX,&x);CHKERRQ(ierr);
  ierr = VecGetArray(F,&f);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 1, &fStart, &fEnd);CHKERRQ(ierr);
  for (face = fStart; face < fEnd; ++face) {
    const PetscInt    *cells;
    PetscInt          i,ghost;
    PetscScalar       *flux = user->work.flux,*fL,*fR;
    const FaceGeom    *fg;
    const CellGeom    *cgL,*cgR;
    const PetscScalar *xL,*xR;

    ierr = DMComplexGetLabelValue(dm, "ghost", face, &ghost);CHKERRQ(ierr);
    if (ghost >= 0) continue;
    ierr = DMComplexGetSupport(dm, face, &cells);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmFace,face,facegeom,&fg);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmCell,cells[0],cellgeom,&cgL);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmCell,cells[1],cellgeom,&cgR);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dm,cells[0],x,&xL);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dm,cells[1],x,&xR);CHKERRQ(ierr);
    ierr = DMComplexPointGlobalRef(dm,cells[0],f,&fL);CHKERRQ(ierr);
    ierr = DMComplexPointGlobalRef(dm,cells[1],f,&fR);CHKERRQ(ierr);
    ierr = (*phys->riemann)(user->physics, fg->normal, xL, xR, flux);CHKERRQ(ierr);
    for (i=0; i<phys->dof; i++) {
      if (fL) fL[i] -= flux[i] / cgL->volume;
      if (fR) fR[i] += flux[i] / cgR->volume;
    }
  }
  ierr = VecRestoreArrayRead(user->facegeom,&facegeom);CHKERRQ(ierr);
  ierr = VecRestoreArrayRead(user->cellgeom,&cellgeom);CHKERRQ(ierr);
  ierr = VecRestoreArrayRead(locX,&x);CHKERRQ(ierr);
  ierr = VecRestoreArray(F,&f);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "RHSFunctionLocal_LS"
static PetscErrorCode RHSFunctionLocal_LS(DM dm,DM dmFace,DM dmCell,Vec locX,Vec F,User user)
{
  DM                dmGrad = user->dmGrad;
  Physics           phys = user->physics;
  const PetscInt    dof = user->physics->dof;
  PetscErrorCode    ierr;
  const PetscScalar *facegeom, *cellgeom, *x;
  PetscScalar       *f;
  PetscInt          fStart, fEnd, face, cStart, cell;
  Vec               locGrad,Grad;

  PetscFunctionBegin;
  ierr = DMGetLocalVector(dmGrad,&locGrad);CHKERRQ(ierr);
  ierr = VecZeroEntries(locGrad);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->facegeom,&facegeom);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->cellgeom,&cellgeom);CHKERRQ(ierr);
  ierr = VecGetArrayRead(locX,&x);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 1, &fStart, &fEnd);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, PETSC_NULL);CHKERRQ(ierr);
  {
    PetscScalar *grad;
    ierr = VecGetArray(locGrad,&grad);CHKERRQ(ierr);
    /* Reconstruct gradients */
    for (face=fStart; face<fEnd; ++face) {
      const PetscInt    *cells;
      const PetscScalar *cx[2];
      const FaceGeom    *fg;
      PetscScalar       *cgrad[2];
      PetscInt          i,j;

      ierr = DMComplexGetSupport(dm,face,&cells);CHKERRQ(ierr);
      ierr = DMComplexPointLocalRead(dmFace,face,facegeom,&fg);CHKERRQ(ierr);
      for (i=0; i<2; i++) {
        ierr = DMComplexPointLocalRead(dm,cells[i],x,&cx[i]);CHKERRQ(ierr);
        ierr = DMComplexPointLocalRef(dmGrad,cells[i],grad,&cgrad[i]);CHKERRQ(ierr);
      }
      for (i=0; i<dof; i++) {
        PetscScalar delta = cx[1][i] - cx[0][i];
        for (j=0; j<DIM; j++) {
          cgrad[0][i*DIM+j] += fg->grad[0][j] * delta;
          cgrad[1][i*DIM+j] -= fg->grad[1][j] * delta;
        }
      }
    }
    /* Limit interior gradients. Using cell-based loop because it generalizes better to vector limiters. */
    for (cell=cStart; cell<user->cEndInterior; cell++) {
      const PetscInt *faces;
      PetscInt numFaces,f;
      PetscReal *cellPhi = user->work.state0;        /* Scalar limiter applied to each component separately */
      const PetscScalar *cx;
      const CellGeom    *cg;
      PetscScalar       *cgrad;
      PetscInt          i;
      ierr = DMComplexGetConeSize(dm,cell,&numFaces);CHKERRQ(ierr);
      ierr = DMComplexGetCone(dm,cell,&faces);CHKERRQ(ierr);
      ierr = DMComplexPointLocalRead(dm,cell,x,&cx);CHKERRQ(ierr);
      ierr = DMComplexPointLocalRead(dmCell,cell,cellgeom,&cg);CHKERRQ(ierr);
      ierr = DMComplexPointLocalRef(dmGrad,cell,grad,&cgrad);CHKERRQ(ierr);
      /* Limiter will be minimum value over all neighbors */
      for (i=0; i<dof; i++) cellPhi[i] = PETSC_MAX_REAL;
      for (f=0; f<numFaces; f++) {
        const PetscScalar *ncx;
        const CellGeom    *ncg;
        const PetscInt    *fcells;
        PetscInt          face = faces[f],ncell;
        PetscScalar       v[DIM];
        ierr = DMComplexGetSupport(dm,face,&fcells);CHKERRQ(ierr);
        ncell = cell == fcells[0] ? fcells[1] : fcells[0];
        ierr = DMComplexPointLocalRead(dm,ncell,x,&ncx);CHKERRQ(ierr);
        ierr = DMComplexPointLocalRead(dmCell,ncell,cellgeom,&ncg);CHKERRQ(ierr);
        Waxpy2(-1,cg->centroid,ncg->centroid,v);
        for (i=0; i<dof; i++) {
          PetscScalar r,phi;
          r = 2*Dot2(&cgrad[i*DIM],v) / (ncx[i] - cx[i]) - 1; /* equivalent to mirroring a ghost point opposite */
          phi = PetscMax(0,PetscMin(1,r));                    /* minmod */
          cellPhi[i] = PetscMin(cellPhi[i],phi);
        }
      }
      /* Apply limiter to gradient */
      for (i=0; i<dof; i++) Scale2(cellPhi[i],&cgrad[i*DIM],&cgrad[i*DIM]);
    }
    ierr = VecRestoreArray(locGrad,&grad);CHKERRQ(ierr);
  }
  ierr = DMGetGlobalVector(dmGrad,&Grad);CHKERRQ(ierr);
  ierr = DMLocalToGlobalBegin(dmGrad,locGrad,INSERT_VALUES,Grad);CHKERRQ(ierr);
  ierr = DMLocalToGlobalEnd(dmGrad,locGrad,INSERT_VALUES,Grad);CHKERRQ(ierr);
  ierr = DMGlobalToLocalBegin(dmGrad,Grad,INSERT_VALUES,locGrad);CHKERRQ(ierr);
  ierr = DMGlobalToLocalEnd(dmGrad,Grad,INSERT_VALUES,locGrad);CHKERRQ(ierr);
  ierr = DMRestoreGlobalVector(dmGrad,&Grad);CHKERRQ(ierr);

  {
    const PetscScalar *grad;
    ierr = VecGetArrayRead(locGrad,&grad);CHKERRQ(ierr);
    ierr = VecGetArray(F,&f);CHKERRQ(ierr);
    for (face=fStart; face<fEnd; ++face) {
      const PetscInt    *cells;
      PetscInt          ghost,i,j,bset;
      PetscScalar       *flux = user->work.flux,*fx[2] = {user->work.state0,user->work.state1},*cf[2];
      const FaceGeom    *fg;
      const CellGeom    *cg[2];
      const PetscScalar *cx[2],*cgrad[2];

      ierr = DMComplexGetLabelValue(dm, "ghost", face, &ghost);CHKERRQ(ierr);
      if (ghost >= 0) continue;
      ierr = DMComplexGetSupport(dm, face, &cells);CHKERRQ(ierr);
      ierr = DMComplexPointLocalRead(dmFace,face,facegeom,&fg);CHKERRQ(ierr);
      for (i=0; i<2; i++) {
        PetscScalar dx[DIM];
        ierr = DMComplexPointLocalRead(dmCell,cells[i],cellgeom,&cg[i]);CHKERRQ(ierr);
        ierr = DMComplexPointLocalRead(dm,cells[i],x,&cx[i]);CHKERRQ(ierr);
        ierr = DMComplexPointLocalRead(dmGrad,cells[i],grad,&cgrad[i]);CHKERRQ(ierr);
        ierr = DMComplexPointGlobalRef(dm,cells[i],f,&cf[i]);CHKERRQ(ierr);
        Waxpy2(-1,cg[i]->centroid,fg->centroid,dx);
        for (j=0; j<dof; j++) fx[i][j] = cx[i][j] + Dot2(cgrad[i],dx);
      }
      ierr = DMComplexGetLabelValue(dm, "Face Sets", face, &bset);CHKERRQ(ierr);
      if (bset != -1) {
        BoundaryFunction bcFunc;
        ierr = PhysicsBoundaryFind(phys,bset,&bcFunc);CHKERRQ(ierr);
        ierr = (*bcFunc)(phys,fg->normal,fx[0],fx[1]);CHKERRQ(ierr);
      }
      ierr = (*phys->riemann)(user->physics, fg->normal, fx[0], fx[1], flux);CHKERRQ(ierr);
      for (i=0; i<phys->dof; i++) {
        if (cf[0]) cf[0][i] -= flux[i] / cg[0]->volume;
        if (cf[1]) cf[1][i] += flux[i] / cg[1]->volume;
      }
    }
    ierr = VecRestoreArrayRead(locGrad,&grad);CHKERRQ(ierr);
    ierr = VecRestoreArray(F,&f);CHKERRQ(ierr);
  }
  ierr = VecRestoreArrayRead(user->facegeom,&facegeom);CHKERRQ(ierr);
  ierr = VecRestoreArrayRead(user->cellgeom,&cellgeom);CHKERRQ(ierr);
  ierr = VecRestoreArrayRead(locX,&x);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dmGrad,&locGrad);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "RHSFunction"
static PetscErrorCode RHSFunction(TS ts,PetscReal time,Vec X,Vec F,void *ctx)
{
  User               user = (User)ctx;
  DM                 dm, dmFace, dmCell;
  PetscSection       section;
  Vec                locX;
  PetscErrorCode     ierr;

  PetscFunctionBegin;
  ierr = TSGetDM(ts,&dm);CHKERRQ(ierr);
  ierr = VecGetDM(user->facegeom,&dmFace);CHKERRQ(ierr);
  ierr = VecGetDM(user->cellgeom,&dmCell);CHKERRQ(ierr);
  ierr = DMGetLocalVector(dm,&locX);CHKERRQ(ierr);
  ierr = DMGlobalToLocalBegin(dm, X, INSERT_VALUES, locX);CHKERRQ(ierr);
  ierr = DMGlobalToLocalEnd(dm, X, INSERT_VALUES, locX);CHKERRQ(ierr);
  ierr = DMGetDefaultSection(dm, &section);CHKERRQ(ierr);

  ierr = ApplyBC(dm, locX, user);CHKERRQ(ierr);

  ierr = VecZeroEntries(F);CHKERRQ(ierr);
  ierr = (*user->RHSFunctionLocal)(dm,dmFace,dmCell,locX,F,user);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm,&locX);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "OutputVTK"
static PetscErrorCode OutputVTK(DM dm, const char *filename, PetscViewer *viewer)
{
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = PetscViewerCreate(((PetscObject) dm)->comm, viewer);CHKERRQ(ierr);
  ierr = PetscViewerSetType(*viewer, PETSCVIEWERVTK);CHKERRQ(ierr);
  ierr = PetscViewerFileSetName(*viewer, filename);CHKERRQ(ierr);
  ierr = PetscViewerSetFormat(*viewer, PETSC_VIEWER_ASCII_VTK);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "MonitorVTK"
static PetscErrorCode MonitorVTK(TS ts,PetscInt stepnum,PetscReal time,Vec X,void *ctx)
{
  User           user = (User)ctx;
  DM             dm;
  PetscViewer    viewer;
  char           filename[PETSC_MAX_PATH_LEN],*ftable = PETSC_NULL;
  PetscReal      xnorm;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = PetscObjectSetName((PetscObject) X, "solution");CHKERRQ(ierr);
  ierr = VecGetDM(X,&dm);CHKERRQ(ierr);
  ierr = VecNorm(X,NORM_INFINITY,&xnorm);CHKERRQ(ierr);
  if (stepnum >= 0) {           /* No summary for final time */
    Physics phys = user->physics;
    PetscInt c,cStart,cEnd,fcount,i;
    size_t ftableused,ftablealloc;
    const PetscScalar *cellgeom,*x;
    DM dmCell;
    FunctionalLink flink;
    PetscReal *fmin,*fmax,*fintegral,*ftmp;
    for (flink=phys->functional,fcount=0; flink; flink=flink->next) fcount++;
    ierr = PetscMalloc4(fcount,PetscReal,&fmin,fcount,PetscReal,&fmax,fcount,PetscReal,&fintegral,fcount,PetscReal,&ftmp);CHKERRQ(ierr);
    for (i=0; i<fcount; i++) {
      fmin[i] = PETSC_MAX_REAL;
      fmax[i] = PETSC_MIN_REAL;
      fintegral[i] = 0;
    }
    ierr = DMComplexGetHeightStratum(dm,0,&cStart,&cEnd);CHKERRQ(ierr);
    ierr = VecGetDM(user->cellgeom,&dmCell);CHKERRQ(ierr);
    ierr = VecGetArrayRead(user->cellgeom,&cellgeom);CHKERRQ(ierr);
    ierr = VecGetArrayRead(X,&x);CHKERRQ(ierr);
    for (c=cStart; c<user->cEndInterior; c++) {
      const CellGeom *cg;
      const PetscScalar *cx;
      ierr = DMComplexPointLocalRead(dmCell,c,cellgeom,&cg);CHKERRQ(ierr);
      ierr = DMComplexPointGlobalRead(dm,c,x,&cx);CHKERRQ(ierr);
      if (!cx) continue;
      if (phys->monitor) {ierr = (*phys->monitor)(user->physics,cx,ftmp);CHKERRQ(ierr);}
      for (i=0; i<fcount; i++) {
        fmin[i] = PetscMin(fmin[i],ftmp[i]);
        fmax[i] = PetscMax(fmax[i],ftmp[i]);
        fintegral[i] += cg->volume * ftmp[i];
      }
    }
    ierr = VecRestoreArrayRead(user->cellgeom,&cellgeom);CHKERRQ(ierr);
    ierr = VecRestoreArrayRead(X,&x);CHKERRQ(ierr);
    ierr = MPI_Allreduce(MPI_IN_PLACE,fmin,fcount,MPIU_REAL,MPI_MIN,((PetscObject)ts)->comm);CHKERRQ(ierr);
    ierr = MPI_Allreduce(MPI_IN_PLACE,fmax,fcount,MPIU_REAL,MPI_MAX,((PetscObject)ts)->comm);CHKERRQ(ierr);
    ierr = MPI_Allreduce(MPI_IN_PLACE,fintegral,fcount,MPIU_REAL,MPI_SUM,((PetscObject)ts)->comm);CHKERRQ(ierr);

    ftablealloc = fcount * 100;
    ftableused = 0;
    ierr = PetscMalloc(ftablealloc,&ftable);CHKERRQ(ierr);
    for (flink=phys->functional,i=0; i<fcount; flink=flink->next,i++) {
      size_t countused;
      char buffer[256],*p;
      if (i % 3) {
        ierr = PetscMemcpy(buffer,"  ",2);CHKERRQ(ierr);
        p = buffer + 2;
      } else if (i) {
        char newline[] = "\n";
        ierr = PetscMemcpy(buffer,newline,sizeof newline-1);CHKERRQ(ierr);
        p = buffer + sizeof newline - 1;
      } else {
        p = buffer;
      }
      ierr = PetscSNPrintfCount(p,sizeof buffer-(p-buffer),"%12s [%10.7G,%10.7G] int %10.7G",&countused,flink->name,fmin[i],fmax[i],fintegral[i]);CHKERRQ(ierr);
      countused += p - buffer;
      if (countused > ftablealloc-ftableused-1) { /* reallocate */
        char *ftablenew;
        ftablealloc = 2*ftablealloc + countused;
        ierr = PetscMalloc(ftablealloc,&ftablenew);CHKERRQ(ierr);
        ierr = PetscMemcpy(ftablenew,ftable,ftableused);CHKERRQ(ierr);
        ierr = PetscFree(ftable);CHKERRQ(ierr);
        ftable = ftablenew;
      }
      ierr = PetscMemcpy(ftable+ftableused,buffer,countused);CHKERRQ(ierr);
      ftableused += countused;
      ftable[ftableused] = 0;
    }
    ierr = PetscFree4(fmin,fmax,fintegral,ftmp);CHKERRQ(ierr);

    ierr = PetscPrintf(((PetscObject)ts)->comm,"% 3D  time %8.4G  |x| %8.4G  %s\n",stepnum,time,xnorm,ftable?ftable:"");CHKERRQ(ierr);
    ierr = PetscFree(ftable);CHKERRQ(ierr);
  }
  if (user->vtkInterval < 1) PetscFunctionReturn(0);
  if ((stepnum == -1) ^ (stepnum % user->vtkInterval == 0)) {
    if (stepnum == -1) {        /* Final time is not multiple of normal time interval, write it anyway */
      ierr = TSGetTimeStepNumber(ts,&stepnum);CHKERRQ(ierr);
    }
    ierr = PetscSNPrintf(filename,sizeof filename,"ex11-%03D.vtk",stepnum);CHKERRQ(ierr);
    ierr = OutputVTK(dm,filename,&viewer);CHKERRQ(ierr);
    ierr = VecView(X,viewer);CHKERRQ(ierr);
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  }
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "main"
int main(int argc, char **argv)
{
  MPI_Comm       comm;
  User           user;
  DM             dm, dmDist;
  PetscReal      ftime,cfl,dt;
  PetscInt       dim, overlap, nsteps;
  int            CPU_word_size = 0, IO_word_size = 0, exoid;
  float          version;
  TS             ts;
  TSConvergedReason reason;
  Vec            X;
  PetscViewer    viewer;
  PetscMPIInt    rank;
  char           filename[PETSC_MAX_PATH_LEN] = "sevenside.exo";
  PetscBool      vtkCellGeom;
  PetscErrorCode ierr;

  ierr = PetscInitialize(&argc, &argv, (char *) 0, help);CHKERRQ(ierr);
  comm = PETSC_COMM_WORLD;
  ierr = MPI_Comm_rank(comm, &rank);CHKERRQ(ierr);

  ierr = PetscNew(struct _n_User,&user);CHKERRQ(ierr);
  ierr = PetscNew(struct _n_Physics,&user->physics);CHKERRQ(ierr);
  user->comm = comm;

  /* Register physical models to be available on the command line */
  ierr = PetscFListAdd(&PhysicsList,"advect"          ,"",(void(*)(void))PhysicsCreate_Advect);CHKERRQ(ierr);
  ierr = PetscFListAdd(&PhysicsList,"sw"              ,"",(void(*)(void))PhysicsCreate_SW);CHKERRQ(ierr);

  ierr = PetscOptionsBegin(comm,PETSC_NULL,"Unstructured Finite Volume Options","");CHKERRQ(ierr);
  {
    char physname[256] = "advect";
    PetscErrorCode (*physcreate)(User,Physics);
    cfl = 0.9 * 4;              /* default SSPRKS2 with s=5 stages is stable for CFL number s-1 */
    ierr = PetscOptionsReal("-ufv_cfl","CFL number per step","",cfl,&cfl,PETSC_NULL);CHKERRQ(ierr);
    ierr = PetscOptionsString("-f","Exodus.II filename to read","",filename,filename,sizeof(filename),PETSC_NULL);CHKERRQ(ierr);
    user->vtkInterval = 1;
    ierr = PetscOptionsInt("-ufv_vtk_interval","VTK output interval (0 to disable)","",user->vtkInterval,&user->vtkInterval,PETSC_NULL);CHKERRQ(ierr);
    overlap = 1;
    ierr = PetscOptionsInt("-ufv_mesh_overlap","Number of cells to overlap partitions","",overlap,&overlap,PETSC_NULL);CHKERRQ(ierr);
    vtkCellGeom = PETSC_FALSE;
    ierr = PetscOptionsBool("-ufv_vtk_cellgeom","Write cell geometry (for debugging)","",vtkCellGeom,&vtkCellGeom,PETSC_NULL);CHKERRQ(ierr);
    ierr = PetscOptionsList("-physics","Physics module to solve","",PhysicsList,physname,physname,sizeof physname,PETSC_NULL);CHKERRQ(ierr);
    ierr = PetscFListFind(PhysicsList,comm,physname,PETSC_TRUE,(void(**)(void))&physcreate);CHKERRQ(ierr);
    ierr = PetscMemzero(user->physics,sizeof(struct _n_Physics));CHKERRQ(ierr);
    ierr = (*physcreate)(user,user->physics);CHKERRQ(ierr);
    if (user->physics->maxspeed <= 0) SETERRQ1(comm,PETSC_ERR_ARG_WRONGSTATE,"Physics '%s' did not set maxspeed",physname);
    if (user->physics->dof <= 0) SETERRQ1(comm,PETSC_ERR_ARG_WRONGSTATE,"Physics '%s' did not set dof",physname);
    ierr = PetscMalloc3(user->physics->dof,PetscScalar,&user->work.flux,user->physics->dof,PetscScalar,&user->work.state0,user->physics->dof,PetscScalar,&user->work.state1);CHKERRQ(ierr);
    user->reconstruct = PETSC_FALSE;
    ierr = PetscOptionsBool("-ufv_reconstruct","Reconstruct gradients for a second order method (grows stencil)","",user->reconstruct,&user->reconstruct,PETSC_NULL);CHKERRQ(ierr);
    user->RHSFunctionLocal = user->reconstruct ? RHSFunctionLocal_LS : RHSFunctionLocal_Upwind;
  }
  ierr = PetscOptionsEnd();CHKERRQ(ierr);

  if (!rank) {
    exoid = ex_open(filename, EX_READ, &CPU_word_size, &IO_word_size, &version);
    if (exoid <= 0) SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_LIB,"ex_open(\"%s\",...) did not return a valid file ID",filename);
  } else exoid = -1;                 /* Not used */
  ierr = DMComplexCreateExodus(comm, exoid, PETSC_TRUE, &dm);CHKERRQ(ierr);
  if (!rank) {ierr = ex_close(exoid);CHKERRQ(ierr);}
  /* Distribute mesh */
  ierr = DMComplexDistribute(dm, "chaco", overlap, &dmDist);CHKERRQ(ierr);
  if (dmDist) {
    ierr = DMDestroy(&dm);CHKERRQ(ierr);
    dm   = dmDist;
  }
  ierr = DMSetFromOptions(dm);CHKERRQ(ierr);

  ierr = ConstructGhostCells(&dm, user);CHKERRQ(ierr);
  ierr = ConstructGeometry(dm, &user->facegeom, &user->cellgeom, user);CHKERRQ(ierr);
  if (0) {ierr = VecView(user->cellgeom, PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);}
  ierr = DMComplexGetDimension(dm, &dim);CHKERRQ(ierr);
  ierr = DMComplexSetPreallocationCenterDimension(dm, 0);CHKERRQ(ierr);

  /* Set up DM with section describing local vector and configure local vector. */
  ierr = SetUpLocalSpace(dm, user);CHKERRQ(ierr);
  ierr = SetUpBoundaries(dm, user);CHKERRQ(ierr);

  ierr = DMCreateGlobalVector(dm, &X);CHKERRQ(ierr);
  ierr = PetscObjectSetName((PetscObject) X, "solution");CHKERRQ(ierr);
  ierr = SetInitialCondition(dm, X, user);CHKERRQ(ierr);
  if (vtkCellGeom) {
    DM  dmCell;
    Vec partition;

    ierr = OutputVTK(dm, "ex11-cellgeom.vtk", &viewer);CHKERRQ(ierr);
    ierr = VecView(user->cellgeom, viewer);CHKERRQ(ierr);
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
    ierr = CreatePartitionVec(dm, &dmCell, &partition);CHKERRQ(ierr);
    ierr = OutputVTK(dmCell, "ex11-partition.vtk", &viewer);CHKERRQ(ierr);
    ierr = VecView(partition, viewer);CHKERRQ(ierr);
    ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
    ierr = VecDestroy(&partition);CHKERRQ(ierr);
    ierr = DMDestroy(&dmCell);CHKERRQ(ierr);
  }

  ierr = TSCreate(comm, &ts);CHKERRQ(ierr);
  ierr = TSSetType(ts, TSSSP);CHKERRQ(ierr);
  ierr = TSSetDM(ts, dm);CHKERRQ(ierr);
  ierr = TSMonitorSet(ts,MonitorVTK,user,PETSC_NULL);CHKERRQ(ierr);
  ierr = TSSetRHSFunction(ts,PETSC_NULL,RHSFunction,user);CHKERRQ(ierr);
  ierr = TSSetDuration(ts,1000,2.0);CHKERRQ(ierr);
  dt = cfl * user->minradius / user->physics->maxspeed;
  ierr = TSSetInitialTimeStep(ts,0.0,dt);CHKERRQ(ierr);
  ierr = TSSetFromOptions(ts);CHKERRQ(ierr);
  ierr = TSSolve(ts,X);CHKERRQ(ierr);
  ierr = TSGetSolveTime(ts,&ftime);CHKERRQ(ierr);
  ierr = TSGetTimeStepNumber(ts,&nsteps);CHKERRQ(ierr);
  ierr = TSGetConvergedReason(ts,&reason);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD,"%s at time %G after %D steps\n",TSConvergedReasons[reason],ftime,nsteps);CHKERRQ(ierr);
  ierr = TSDestroy(&ts);CHKERRQ(ierr);

  ierr = VecDestroy(&user->cellgeom);CHKERRQ(ierr);
  ierr = VecDestroy(&user->facegeom);CHKERRQ(ierr);
  ierr = DMDestroy(&user->dmGrad);CHKERRQ(ierr);
  ierr = PetscFListDestroy(&PhysicsList);CHKERRQ(ierr);
  ierr = BoundaryLinkDestroy(&user->physics->boundary);CHKERRQ(ierr);
  ierr = FunctionalLinkDestroy(&user->physics->functional);CHKERRQ(ierr);
  ierr = PetscFree(user->physics->data);CHKERRQ(ierr);
  ierr = PetscFree(user->physics);CHKERRQ(ierr);
  ierr = PetscFree3(user->work.flux,user->work.state0,user->work.state1);CHKERRQ(ierr);
  ierr = PetscFree(user);CHKERRQ(ierr);
  ierr = VecDestroy(&X);CHKERRQ(ierr);
  ierr = DMDestroy(&dm);CHKERRQ(ierr);
  ierr = PetscFinalize();
  return(0);
}
