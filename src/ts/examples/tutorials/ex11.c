static char help[] = "Second Order TVD Finite Volume Example.\n";
/*
  The mesh is read in from an ExodusII file generated by Cubit.
*/
#include <petscts.h>
#include <petscdmcomplex.h>
#ifdef PETSC_HAVE_EXODUSII
#include <exodusII.h>
#else
#error This example requires ExodusII support. Reconfigure using --download-exodusii
#endif

#define DIM 2                   /* Geometric dimension */

typedef struct {
  PetscInt  numGhostCells, cEndInterior;
  Vec       cellgeom, facegeom;
  PetscReal wind[DIM];
} AppCtx;

typedef struct {
  PetscScalar normal[DIM];              /* Area-scaled normals */
  PetscScalar centroid[DIM];            /* Location of centroid (quadrature point) */
} FaceGeom;

typedef struct {
  PetscScalar centroid[DIM];
  PetscScalar area;
} CellGeom;

PETSC_STATIC_INLINE PetscScalar Dot2(const PetscScalar *x,const PetscScalar *y) { return x[0]*x[0] + x[1]*y[1];}
PETSC_STATIC_INLINE PetscReal Norm2(const PetscScalar *x) { return PetscSqrtReal(PetscAbsScalar(Dot2(x,x)));}

#undef __FUNCT__
#define __FUNCT__ "ConstructGhostCells"
PetscErrorCode ConstructGhostCells(DM *dmGhosted, AppCtx *user)
{
  DM              dm = *dmGhosted, gdm;
  PetscSection    coordSection, newCoordSection;
  Vec             coordinates;
  const char     *name = "Face Sets";
  IS              idIS;
  const PetscInt *ids;
  PetscInt       *newpoints;
  PetscInt        dim, depth, d, maxConeSize, maxSupportSize, numLabels, l;
  PetscInt        numFS, fs, pStart, pEnd, p, cStart, cEnd, c, ghostCell, vStart, vEnd, v;
  PetscErrorCode  ierr;

  PetscFunctionBegin;
  ierr = DMCreate(((PetscObject) dm)->comm, &gdm);CHKERRQ(ierr);
  ierr = DMSetType(gdm, DMCOMPLEX);CHKERRQ(ierr);
  ierr = DMComplexGetDimension(dm, &dim);CHKERRQ(ierr);
  ierr = DMComplexSetDimension(gdm, dim);CHKERRQ(ierr);

  ierr = DMComplexGetLabelIdIS(dm, name, &idIS);CHKERRQ(ierr);
  ierr = ISGetLocalSize(idIS, &numFS);CHKERRQ(ierr);
  ierr = ISGetIndices(idIS, &ids);CHKERRQ(ierr);
  user->numGhostCells = 0;
  for(fs = 0; fs < numFS; ++fs) {
    PetscInt numBdFaces;

    ierr = DMComplexGetStratumSize(dm, name, ids[fs], &numBdFaces);CHKERRQ(ierr);
    user->numGhostCells += numBdFaces;
  }
  ierr = DMComplexGetChart(dm, &pStart, &pEnd);CHKERRQ(ierr);
  pEnd += user->numGhostCells;
  ierr = DMComplexSetChart(gdm, pStart, pEnd);CHKERRQ(ierr);
  /* Set cone and support sizes */
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  user->cEndInterior = cEnd;
  for(c = cStart; c < cEnd; ++c) {
    PetscInt size;

    ierr = DMComplexGetConeSize(dm, c, &size);CHKERRQ(ierr);
    ierr = DMComplexSetConeSize(gdm, c, size);CHKERRQ(ierr);
  }
  for(c = cEnd; c < cEnd+user->numGhostCells; ++c) {
    ierr = DMComplexSetConeSize(gdm, c, 1);CHKERRQ(ierr);
  }
  ierr = DMComplexGetDepth(dm, &depth);CHKERRQ(ierr);
  for(d = 0; d < depth; ++d) {
    ierr = DMComplexGetDepthStratum(dm, d, &pStart, &pEnd);CHKERRQ(ierr);
    for(p = pStart; p < pEnd; ++p) {
      PetscInt newp = p+user->numGhostCells;
      PetscInt size;

      ierr = DMComplexGetConeSize(dm, p, &size);CHKERRQ(ierr);
      ierr = DMComplexSetConeSize(gdm, newp, size);CHKERRQ(ierr);
      ierr = DMComplexGetSupportSize(dm, p, &size);CHKERRQ(ierr);
      ierr = DMComplexSetSupportSize(gdm, newp, size);CHKERRQ(ierr);
    }
  }
  for(fs = 0; fs < numFS; ++fs) {
    IS              faceIS;
    const PetscInt *faces;
    PetscInt        numFaces, f;

    ierr = DMComplexGetStratumIS(dm, name, ids[fs], &faceIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(faceIS, &numFaces);CHKERRQ(ierr);
    ierr = ISGetIndices(faceIS, &faces);CHKERRQ(ierr);
    for(f = 0; f < numFaces; ++f) {
      PetscInt size;

      ierr = DMComplexGetSupportSize(dm, faces[f], &size);CHKERRQ(ierr);
      if (size != 1) SETERRQ2(((PetscObject) dm)->comm, PETSC_ERR_ARG_WRONG, "DM has boundary face %d with %d support cells", faces[f], size);
      ierr = DMComplexSetSupportSize(gdm, faces[f]+user->numGhostCells, 2);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(faceIS, &faces);CHKERRQ(ierr);
    ierr = ISDestroy(&faceIS);CHKERRQ(ierr);
  }
  ierr = DMSetUp(gdm);CHKERRQ(ierr);
  /* Set cones and supports, may have to orient supports here */
  ierr = DMComplexGetMaxSizes(dm, &maxConeSize, &maxSupportSize);CHKERRQ(ierr);
  ierr = PetscMalloc(PetscMax(maxConeSize, maxSupportSize) * sizeof(PetscInt), &newpoints);CHKERRQ(ierr);
  ierr = DMComplexGetChart(dm, &pStart, &pEnd);CHKERRQ(ierr);
  for(p = pStart; p < pEnd; ++p) {
    const PetscInt *points, *orientations;
    PetscInt        size, i, newp = p >= cEnd ? p+user->numGhostCells : p;

    ierr = DMComplexGetConeSize(dm, p, &size);CHKERRQ(ierr);
    ierr = DMComplexGetCone(dm, p, &points);CHKERRQ(ierr);
    ierr = DMComplexGetConeOrientation(dm, p, &orientations);CHKERRQ(ierr);
    for(i = 0; i < size; ++i) {
      newpoints[i] = points[i] >= cEnd ? points[i]+user->numGhostCells : points[i];
    }
    ierr = DMComplexSetCone(gdm, newp, newpoints);CHKERRQ(ierr);
    ierr = DMComplexSetConeOrientation(gdm, newp, orientations);CHKERRQ(ierr);
    ierr = DMComplexGetSupportSize(dm, p, &size);CHKERRQ(ierr);
    ierr = DMComplexGetSupport(dm, p, &points);CHKERRQ(ierr);
    for(i = 0; i < size; ++i) {
      newpoints[i] = points[i] >= cEnd ? points[i]+user->numGhostCells : points[i];
    }
    ierr = DMComplexSetSupport(gdm, newp, newpoints);CHKERRQ(ierr);
  }
  ierr = PetscFree(newpoints);CHKERRQ(ierr);
  ghostCell = cEnd;
  for(fs = 0; fs < numFS; ++fs) {
    IS              faceIS;
    const PetscInt *faces;
    PetscInt        numFaces, f;

    ierr = DMComplexGetStratumIS(dm, name, ids[fs], &faceIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(faceIS, &numFaces);CHKERRQ(ierr);
    ierr = ISGetIndices(faceIS, &faces);CHKERRQ(ierr);
    for(f = 0; f < numFaces; ++f, ++ghostCell) {
      PetscInt newFace = faces[f] + user->numGhostCells;

      ierr = DMComplexSetCone(gdm, ghostCell, &newFace);CHKERRQ(ierr);
      ierr = DMComplexInsertSupport(gdm, newFace, 1, ghostCell);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(faceIS, &faces);CHKERRQ(ierr);
    ierr = ISDestroy(&faceIS);CHKERRQ(ierr);
  }
  ierr = ISRestoreIndices(idIS, &ids);CHKERRQ(ierr);
  ierr = ISDestroy(&idIS);CHKERRQ(ierr);
  ierr = DMComplexStratify(gdm);CHKERRQ(ierr);
  /* Convert coordinates */
  ierr = DMComplexGetDepthStratum(dm, 0, &vStart, &vEnd);CHKERRQ(ierr);
  ierr = DMComplexGetCoordinateSection(dm, &coordSection);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &newCoordSection);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(newCoordSection, vStart+user->numGhostCells, vEnd+user->numGhostCells);CHKERRQ(ierr);
  for(v = vStart; v < vEnd; ++v) {
    ierr = PetscSectionSetDof(newCoordSection, v+user->numGhostCells, dim);CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(newCoordSection);CHKERRQ(ierr);
  ierr = DMComplexSetCoordinateSection(gdm, newCoordSection);CHKERRQ(ierr);
  ierr = DMGetCoordinatesLocal(dm, &coordinates);CHKERRQ(ierr);
  ierr = DMSetCoordinatesLocal(gdm, coordinates);CHKERRQ(ierr);
  /* Convert labels */
  ierr = DMComplexGetNumLabels(dm, &numLabels);CHKERRQ(ierr);
  for(l = 0; l < numLabels; ++l) {
    const char *lname;
    PetscBool   isDepth;

    ierr = DMComplexGetLabelName(dm, l, &lname);CHKERRQ(ierr);
    ierr = PetscStrcmp(lname, "depth", &isDepth);CHKERRQ(ierr);
    if (isDepth) continue;
    ierr = DMComplexGetLabelIdIS(dm, lname, &idIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(idIS, &numFS);CHKERRQ(ierr);
    ierr = ISGetIndices(idIS, &ids);CHKERRQ(ierr);
    for(fs = 0; fs < numFS; ++fs) {
      IS              pointIS;
      const PetscInt *points;
      PetscInt        numPoints;

      ierr = DMComplexGetStratumIS(dm, lname, ids[fs], &pointIS);CHKERRQ(ierr);
      ierr = ISGetLocalSize(pointIS, &numPoints);CHKERRQ(ierr);
      ierr = ISGetIndices(pointIS, &points);CHKERRQ(ierr);
      for(p = 0; p < numPoints; ++p) {
        PetscInt newpoint = points[p] >= cEnd ? points[p]+user->numGhostCells : points[p];

        ierr = DMComplexSetLabelValue(gdm, lname, newpoint, ids[fs]);CHKERRQ(ierr);
      }
      ierr = ISRestoreIndices(pointIS, &points);CHKERRQ(ierr);
      ierr = ISDestroy(&pointIS);CHKERRQ(ierr);
    }
    ierr = ISRestoreIndices(idIS, &ids);CHKERRQ(ierr);
    ierr = ISDestroy(&idIS);CHKERRQ(ierr);
  }
  /* Turn off visualization of ghost cells */
  ierr = DMComplexSetVTKBounds(gdm, cEnd, PETSC_DETERMINE);CHKERRQ(ierr);

  ierr = DMSetFromOptions(gdm);CHKERRQ(ierr);
  ierr = DMDestroy(dmGhosted);CHKERRQ(ierr);
  *dmGhosted = gdm;
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "ConstructGeometry"
/* Set up face data and cell data */
PetscErrorCode ConstructGeometry(DM dm, Vec *facegeom, Vec *cellgeom)
{
  DM             dmFace, dmCell;
  PetscSection   sectionFace, sectionCell;
  PetscSection   coordSection;
  Vec            coordinates;
  PetscScalar    *fgeom, *cgeom;
  PetscInt       cStart, cEnd, c, fStart, fEnd, f;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMComplexGetCoordinateSection(dm, &coordSection);CHKERRQ(ierr);
  ierr = DMGetCoordinatesLocal(dm, &coordinates);CHKERRQ(ierr);

  /* Make centroids and areas */
  ierr = DMComplexClone(dm, &dmCell);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &sectionCell);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(sectionCell, cStart, cEnd);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    ierr = PetscSectionSetDof(sectionCell, c, sizeof(CellGeom)/sizeof(PetscScalar));CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(sectionCell);CHKERRQ(ierr);
  ierr = DMSetDefaultSection(dmCell, sectionCell);CHKERRQ(ierr);

  ierr = DMCreateLocalVector(dmCell, cellgeom);CHKERRQ(ierr);
  ierr = VecGetArray(*cellgeom, &cgeom);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    const PetscScalar *coords = PETSC_NULL;
    PetscInt           coordSize, numCorners, p;
    PetscScalar        sx = 0,sy = 0;
    CellGeom           *cg;

    ierr = DMComplexVecGetClosure(dm, coordSection, coordinates, c, &coordSize, &coords);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRef(dmCell, c, cgeom, &cg);CHKERRQ(ierr);
    ierr = PetscMemzero(cg,sizeof(*cg));CHKERRQ(ierr);
    numCorners = coordSize/DIM;
    for(p = 0; p < numCorners; ++p) {
      const PetscScalar *x = coords+p*DIM, *y = coords+((p+1)%numCorners)*DIM;
      const PetscScalar cross = x[0]*y[1] - x[1]*y[0];
      cg->area += 0.5*cross;
      sx += (x[0] + y[0])*cross;
      sy += (x[1] + y[1])*cross;
    }
    cg->centroid[0] = sx / (6*cg->area);
    cg->centroid[1] = sy / (6*cg->area);
    cg->area = PetscAbsScalar(cg->area);
    ierr = DMComplexVecRestoreClosure(dm, coordSection, coordinates, c, &coordSize, &coords);CHKERRQ(ierr);
  }

  /* Make normals */
  ierr = DMComplexClone(dm, &dmFace);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &sectionFace);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 1, &fStart, &fEnd);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(sectionFace, fStart, fEnd);CHKERRQ(ierr);
  for(f = fStart; f < fEnd; ++f) {
    ierr = PetscSectionSetDof(sectionFace, f, sizeof(FaceGeom)/sizeof(PetscScalar));CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(sectionFace);CHKERRQ(ierr);
  ierr = DMSetDefaultSection(dmFace, sectionFace);CHKERRQ(ierr);
  ierr = DMCreateLocalVector(dmFace, facegeom);CHKERRQ(ierr);
  ierr = VecGetArray(*facegeom, &fgeom);CHKERRQ(ierr);
  for(f = fStart; f < fEnd; ++f) {
    const PetscScalar *coords = PETSC_NULL;
    const PetscInt     *cells;
    PetscInt           coordSize;
    PetscScalar        v[2];
    FaceGeom           *fg;
    CellGeom           *cL,*cR;

    ierr = DMComplexVecGetClosure(dm, coordSection, coordinates, f, &coordSize, &coords);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRef(dmFace, f, fgeom, &fg);CHKERRQ(ierr);
    /* Only support edges right now */
    if (coordSize != DIM*2) SETERRQ(((PetscObject) dm)->comm, PETSC_ERR_SUP, "We only support edges right now");
    fg->centroid[0] = 0.5*(coords[0] + coords[DIM]);
    fg->centroid[1] = 0.5*(coords[1] + coords[DIM+1]);
    fg->normal[0] = (coords[1] - coords[DIM+1]);
    fg->normal[1] = -(coords[0] - coords[DIM+0]);
    ierr = DMComplexVecRestoreClosure(dm, coordSection, coordinates, f, &coordSize, &coords);CHKERRQ(ierr);
    /* Flip orientation if necessary to match ordering in support */
    ierr = DMComplexGetSupport(dm, f, &cells);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmCell, cells[0], cgeom, &cL);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmCell, cells[1], cgeom, &cR);CHKERRQ(ierr);
    v[0] = cR->centroid[0] - cL->centroid[0];
    v[1] = cR->centroid[1] - cL->centroid[1];
    if (Dot2(fg->normal, v) < 0) {
      fg->normal[0] = -fg->normal[0];
      fg->normal[1] = -fg->normal[1];
    }
  }
  ierr = VecRestoreArray(*facegeom, &fgeom);CHKERRQ(ierr);
  ierr = VecRestoreArray(*cellgeom, &cgeom);CHKERRQ(ierr);
  ierr = DMDestroy(&dmCell);CHKERRQ(ierr);
  ierr = DMDestroy(&dmFace);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SetUpLocalSpace"
PetscErrorCode SetUpLocalSpace(DM dm, PetscInt numGhostCells)
{
  PetscSection   stateSection;
  PetscInt       dof = 1, *cind, d, stateSize, cStart, cEnd, c;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = PetscSectionCreate(((PetscObject) dm)->comm, &stateSection);CHKERRQ(ierr);
  ierr = PetscSectionSetChart(stateSection, cStart, cEnd);CHKERRQ(ierr);
  for(c = cStart; c < cEnd; ++c) {
    ierr = PetscSectionSetDof(stateSection, c, dof);CHKERRQ(ierr);
  }
  for(c = cEnd-numGhostCells; c < cEnd; ++c) {
    ierr = PetscSectionSetConstraintDof(stateSection, c, dof);CHKERRQ(ierr);
  }
  ierr = PetscSectionSetUp(stateSection);CHKERRQ(ierr);
  ierr = PetscMalloc(dof * sizeof(PetscInt), &cind);CHKERRQ(ierr);
  for(d = 0; d < dof; ++d) cind[d] = d;
  for(c = cEnd-numGhostCells; c < cEnd; ++c) {
    ierr = PetscSectionSetConstraintIndices(stateSection, c, cind);CHKERRQ(ierr);
  }
  ierr = PetscFree(cind);CHKERRQ(ierr);
  ierr = PetscSectionGetStorageSize(stateSection, &stateSize);CHKERRQ(ierr);
  ierr = DMSetDefaultSection(dm,stateSection);CHKERRQ(ierr);
  if (0) {                      /* Crazy that DMSetDefaultSection does not increment refct */
    ierr = PetscSectionDestroy(&stateSection);CHKERRQ(ierr);
  }
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "CopyToGhosts"
/* Iterate over boundary faces copying state from the cell inside into the ghost cell. */
PetscErrorCode CopyToGhosts(DM dm, AppCtx *user, Vec locX)
{
  const char     *name = "Face Sets";
  IS              idIS;
  const PetscInt *ids;
  PetscSection    stateSection;
  PetscScalar    *state;
  PetscInt        numFS, fs;
  PetscErrorCode  ierr;

  PetscFunctionBegin;
  ierr = DMGetDefaultSection(dm, &stateSection);CHKERRQ(ierr);
  ierr = DMComplexGetLabelIdIS(dm, name, &idIS);CHKERRQ(ierr);
  ierr = ISGetLocalSize(idIS, &numFS);CHKERRQ(ierr);
  ierr = ISGetIndices(idIS, &ids);CHKERRQ(ierr);
  ierr = VecGetArray(locX, &state);CHKERRQ(ierr);
  for(fs = 0; fs < numFS; ++fs) {
    IS              faceIS;
    const PetscInt *faces;
    PetscInt        numFaces, f;

    ierr = DMComplexGetStratumIS(dm, name, ids[fs], &faceIS);CHKERRQ(ierr);
    ierr = ISGetLocalSize(faceIS, &numFaces);CHKERRQ(ierr);
    ierr = ISGetIndices(faceIS, &faces);CHKERRQ(ierr);
    for(f = 0; f < numFaces; ++f) {
      const PetscInt  face = faces[f];
      const PetscInt *cells;
      PetscInt        numCells;

      ierr = DMComplexGetSupportSize(dm, face, &numCells);CHKERRQ(ierr);
      ierr = DMComplexGetSupport(dm, face, &cells);CHKERRQ(ierr);
      if (numCells != 2) SETERRQ2(((PetscObject) dm)->comm, PETSC_ERR_ARG_WRONG, "DM has %d > 2 cells for face %d", numCells, f);
      PetscInt dof, off, gdof, goff, d;

      ierr = PetscSectionGetDof(stateSection, cells[0], &dof);CHKERRQ(ierr);
      ierr = PetscSectionGetOffset(stateSection, cells[0], &off);CHKERRQ(ierr);
      ierr = PetscSectionGetDof(stateSection, cells[1], &gdof);CHKERRQ(ierr);
      ierr = PetscSectionGetOffset(stateSection, cells[1], &goff);CHKERRQ(ierr);
      for(d = 0; d < dof; ++d) {
        state[goff+d] = state[off+d];
      }
    }
    ierr = ISRestoreIndices(faceIS, &faces);CHKERRQ(ierr);
    ierr = ISDestroy(&faceIS);CHKERRQ(ierr);
  }
  ierr = VecRestoreArray(locX, &state);CHKERRQ(ierr);
  ierr = ISRestoreIndices(idIS, &ids);CHKERRQ(ierr);
  ierr = ISDestroy(&idIS);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "SetInitialCondition"
PetscErrorCode SetInitialCondition(DM dm, Vec X, AppCtx *user)
{
  DM                 dmCell;
  Vec                locX;
  const PetscScalar  *cellgeom;
  PetscScalar        *x;
  PetscInt           cStart, cEnd, cEndInterior = user->cEndInterior, c;
  PetscErrorCode     ierr;

  PetscFunctionBegin;
  ierr = VecGetDM(user->cellgeom, &dmCell);CHKERRQ(ierr);
  ierr = DMGetLocalVector(dm, &locX);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 0, &cStart, &cEnd);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->cellgeom, &cellgeom);CHKERRQ(ierr);
  ierr = VecGetArray(locX, &x);CHKERRQ(ierr);
  for(c = cStart; c < cEndInterior; ++c) {
    const CellGeom *cg;
    PetscScalar *xc;

    ierr = DMComplexPointLocalRead(dmCell,c,cellgeom,&cg);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRef(dm,c,x,&xc);CHKERRQ(ierr);
    xc[0] = cg->centroid[0] + 3*cg->centroid[1];
  }
  ierr = VecRestoreArrayRead(user->cellgeom, &cellgeom);CHKERRQ(ierr);
  ierr = VecRestoreArray(locX, &x);CHKERRQ(ierr);
  ierr = DMLocalToGlobalBegin(dm, locX, INSERT_VALUES, X);CHKERRQ(ierr);
  ierr = DMLocalToGlobalEnd(dm, locX, INSERT_VALUES, X);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm, &locX);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "CalculateFlux"
/* Iterate over all faces and give me access to solution state + residual for the cells on both sides. */
PetscErrorCode CalculateFlux(DM dm, AppCtx *user, Vec locX, Vec locF)
{
  PetscSection   stateSection;
  PetscScalar   *state, *residual;
  PetscInt       fStart, fEnd, f;
  PetscErrorCode ierr;

  PetscFunctionBegin;
  ierr = DMGetDefaultSection(dm, &stateSection);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 1, &fStart, &fEnd);CHKERRQ(ierr);
  ierr = VecGetArray(locX, &state);CHKERRQ(ierr);
  ierr = VecGetArray(locF, &residual);CHKERRQ(ierr);
  for(f = fStart; f < fEnd; ++f) {
    const PetscInt *cells;
    PetscInt        numCells, c;

    ierr = DMComplexGetSupportSize(dm, f, &numCells);CHKERRQ(ierr);
    ierr = DMComplexGetSupport(dm, f, &cells);CHKERRQ(ierr);
    if (numCells != 2) SETERRQ2(((PetscObject) dm)->comm, PETSC_ERR_ARG_WRONG, "DM has %d > 2 cells for face %d", numCells, f);
    for(c = 0; c < numCells; ++c) {
      PetscInt dof, off, d;

      ierr = PetscSectionGetDof(stateSection, cells[c], &dof);CHKERRQ(ierr);
      ierr = PetscSectionGetOffset(stateSection, cells[c], &off);CHKERRQ(ierr);
      for(d = 0; d < dof; ++d) {
        residual[off+d] = state[off+d];
      }
    }
  }
  ierr = VecRestoreArray(locX, &state);CHKERRQ(ierr);
  ierr = VecRestoreArray(locF, &residual);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "Riemann"
PetscErrorCode Riemann(AppCtx *user, const PetscReal *n, const PetscScalar *xL, const PetscScalar *xR, PetscScalar *flux)
{
  PetscReal wn;

  PetscFunctionBegin;
  wn = Dot2(user->wind, n);
  if (wn > 0) {
    flux[0] = xL[0]*wn;
  } else {
    flux[0] = xR[0]*wn;
  }
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "RHSFunction"
static PetscErrorCode RHSFunction(TS ts,PetscReal time,Vec X,Vec F,void *ctx)
{
  AppCtx *user = (AppCtx*)ctx;
  PetscErrorCode ierr;
  DM             dm,dmFace,dmCell;
  Vec            locX, locF;
  const PetscScalar *facegeom,*cellgeom,*x;
  PetscScalar    *f;
  PetscSection   section;
  PetscInt       face, faceStart, faceEnd;

  PetscFunctionBegin;
  ierr = TSGetDM(ts,&dm);CHKERRQ(ierr);
  ierr = VecGetDM(user->facegeom,&dmFace);CHKERRQ(ierr);
  ierr = VecGetDM(user->cellgeom,&dmCell);CHKERRQ(ierr);
  ierr = DMGetLocalVector(dm,&locX);CHKERRQ(ierr);
  ierr = DMGetLocalVector(dm,&locF);CHKERRQ(ierr);
  ierr = DMGlobalToLocalBegin(dm, X, INSERT_VALUES, locX);CHKERRQ(ierr);
  ierr = DMGlobalToLocalEnd(dm, X, INSERT_VALUES, locX);CHKERRQ(ierr);
  ierr = DMGetDefaultSection(dm, &section);CHKERRQ(ierr);

  ierr = CopyToGhosts(dm, user, locX);CHKERRQ(ierr);

  ierr = VecZeroEntries(locF);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->facegeom,&facegeom);CHKERRQ(ierr);
  ierr = VecGetArrayRead(user->cellgeom,&cellgeom);CHKERRQ(ierr);
  ierr = VecGetArrayRead(locX,&x);CHKERRQ(ierr);
  ierr = VecGetArray(locF,&f);CHKERRQ(ierr);
  ierr = DMComplexGetHeightStratum(dm, 1, &faceStart, &faceEnd);CHKERRQ(ierr);
  for (face=faceStart; face<faceEnd; face++) {
    const PetscInt    *cells,dof = 1;
    PetscInt          i;
    PetscScalar       flux[1],*fL,*fR;
    const FaceGeom    *fg;
    const CellGeom    *cgL,*cgR;
    const PetscScalar *xL,*xR;

    ierr = DMComplexGetSupport(dm, face, &cells);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmFace,face,facegeom,&fg);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmCell,cells[0],cellgeom,&cgL);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dmCell,cells[1],cellgeom,&cgR);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dm,cells[0],x,&xL);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRead(dm,cells[1],x,&xR);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRef(dm,cells[0],f,&fL);CHKERRQ(ierr);
    ierr = DMComplexPointLocalRef(dm,cells[1],f,&fR);CHKERRQ(ierr);
    ierr = Riemann(user, fg->normal, xL, xR, flux);CHKERRQ(ierr);
    for (i=0; i<dof; i++) {
      fL[i] -= flux[i] / cgL->area;
      fR[i] += flux[i] / cgR->area;
    }
  }
  ierr = VecRestoreArrayRead(locX,&x);CHKERRQ(ierr);
  ierr = VecRestoreArray(locF,&f);CHKERRQ(ierr);
  ierr = DMLocalToGlobalBegin(dm,locX,INSERT_VALUES,X);CHKERRQ(ierr);
  ierr = DMLocalToGlobalEnd(dm,locX,INSERT_VALUES,X);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm,&locX);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm,&locF);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "VecViewVTK"
/* Matt refuses to compose the DM with the Vec so that VecView() would work, hence this atrocity. */
static PetscErrorCode VecViewVTK(Vec X,const char *filename)
{
  PetscErrorCode ierr;
  PetscViewer    viewer;
  Vec            locX;
  const char     *name;
  DM             dm;

  PetscFunctionBegin;
  ierr = VecGetDM(X,&dm);CHKERRQ(ierr);
  ierr = PetscViewerCreate(((PetscObject)X)->comm, &viewer);CHKERRQ(ierr);
  ierr = PetscViewerSetType(viewer, PETSCVIEWERVTK);CHKERRQ(ierr);
  ierr = PetscViewerFileSetName(viewer, filename);CHKERRQ(ierr);
  ierr = PetscViewerSetFormat(viewer, PETSC_VIEWER_ASCII_VTK);CHKERRQ(ierr);
  ierr = DMGetLocalVector(dm, &locX);CHKERRQ(ierr);
  ierr = PetscObjectGetName((PetscObject) X, &name);CHKERRQ(ierr);
  ierr = PetscObjectSetName((PetscObject) locX, name);CHKERRQ(ierr);
  ierr = DMGlobalToLocalBegin(dm, X, INSERT_VALUES, locX);CHKERRQ(ierr);
  ierr = DMGlobalToLocalEnd(dm, X, INSERT_VALUES, locX);CHKERRQ(ierr);
  ierr = PetscViewerVTKAddField(viewer, (PetscObject) dm, DMComplexVTKWriteAll, PETSC_VTK_CELL_FIELD, (PetscObject) locX);CHKERRQ(ierr);
  ierr = PetscObjectReference((PetscObject)dm);CHKERRQ(ierr); /* viewer drops reference */
  ierr = PetscObjectReference((PetscObject)locX);CHKERRQ(ierr); /* viewer drops reference */
  ierr = PetscViewerDestroy(&viewer);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm, &locX);CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__
#define __FUNCT__ "main"
int main(int argc, char **argv)
{
  MPI_Comm       comm;
  AppCtx         user;
  DM             dm;
  PetscReal      ftime;
  PetscInt       nsteps;
  int            CPU_word_size = 0, IO_word_size = 0, exoid;
  float          version;
  TS             ts;
  TSConvergedReason reason;
  Vec            X, locX, locF;
  PetscMPIInt    rank;
  char           filename[PETSC_MAX_PATH_LEN] = "sevenside.exo", outfile[PETSC_MAX_PATH_LEN];
  PetscErrorCode ierr;

  ierr = PetscInitialize(&argc, &argv, (char *) 0, help);CHKERRQ(ierr);
  comm = PETSC_COMM_WORLD;
  ierr = MPI_Comm_rank(comm, &rank);CHKERRQ(ierr);

  ierr = PetscOptionsBegin(comm,PETSC_NULL,"Unstructured Finite Volume Options","");CHKERRQ(ierr);
  {
    PetscInt two = 2;
    user.wind[0] = 1.0;
    user.wind[1] = 0.0;
    ierr = PetscOptionsRealArray("-ufv_wind","background wind vx,vy","",user.wind,&two,PETSC_NULL);CHKERRQ(ierr);
    ierr = PetscOptionsString("-f","Exodus.II filename to read","",filename,filename,sizeof filename,PETSC_NULL);CHKERRQ(ierr);
  }
  ierr = PetscOptionsEnd();CHKERRQ(ierr);

  if (!rank) {
    exoid = ex_open(filename, EX_READ, &CPU_word_size, &IO_word_size, &version);
    if (exoid <= 0) SETERRQ1(PETSC_COMM_SELF,PETSC_ERR_LIB,"ex_open(\"%s\",...) did not return a valid file ID",filename);
  }
  ierr = DMComplexCreateExodus(comm, exoid, PETSC_TRUE, &dm);CHKERRQ(ierr);
  if (!rank) {ierr = ex_close(exoid);CHKERRQ(ierr);}
  ierr = DMSetFromOptions(dm);CHKERRQ(ierr);

  ierr = ConstructGhostCells(&dm, &user);CHKERRQ(ierr);

  ierr = ConstructGeometry(dm, &user.facegeom, &user.cellgeom);CHKERRQ(ierr);
  ierr = VecView(user.cellgeom, PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);

  /* Set up DM with section describing local vector and configure local vector. */
  ierr = SetUpLocalSpace(dm, user.numGhostCells);CHKERRQ(ierr);

  ierr = DMCreateGlobalVector(dm, &X);CHKERRQ(ierr);
  ierr = SetInitialCondition(dm, X, &user);CHKERRQ(ierr);
  ierr = VecViewVTK(X, "ex11-000.vtk");CHKERRQ(ierr);
  if (0) {                      /* crashing */
    ierr = VecViewVTK(user.cellgeom, "ex11-cellgeom.vtk");CHKERRQ(ierr);
  }

  ierr = DMGetLocalVector(dm, &locX);CHKERRQ(ierr);
  ierr = DMGetLocalVector(dm, &locF);CHKERRQ(ierr);
  ierr = CopyToGhosts(dm, &user, locX);CHKERRQ(ierr);
  ierr = CalculateFlux(dm, &user, locX, locF);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm, &locX);CHKERRQ(ierr);
  ierr = DMRestoreLocalVector(dm, &locF);CHKERRQ(ierr);

  ierr = TSCreate(comm, &ts);CHKERRQ(ierr);
  ierr = TSSetType(ts, TSSSP);CHKERRQ(ierr);
  ierr = TSSetDM(ts, dm);CHKERRQ(ierr);
  ierr = TSSetRHSFunction(ts,PETSC_NULL,RHSFunction,&user);CHKERRQ(ierr);
  ierr = TSSetDuration(ts,1000,2.0);CHKERRQ(ierr);
  ierr = TSSetInitialTimeStep(ts,0.0,0.1/Norm2(user.wind));CHKERRQ(ierr);
  ierr = TSSetFromOptions(ts);CHKERRQ(ierr);
  ierr = TSSolve(ts,X,&ftime);CHKERRQ(ierr);
  ierr = TSGetTimeStepNumber(ts,&nsteps);CHKERRQ(ierr);
  ierr = TSGetConvergedReason(ts,&reason);CHKERRQ(ierr);
  ierr = PetscPrintf(PETSC_COMM_WORLD,"%s at time %G after %D steps\n",TSConvergedReasons[reason],ftime,nsteps);CHKERRQ(ierr);
  ierr = PetscSNPrintf(outfile,sizeof outfile,"ex11-%03d.vtk",(int)nsteps);CHKERRQ(ierr);
  ierr = VecViewVTK(X, outfile);CHKERRQ(ierr);
  ierr = TSDestroy(&ts);CHKERRQ(ierr);

  ierr = VecDestroy(&user.cellgeom);CHKERRQ(ierr);
  ierr = VecDestroy(&user.facegeom);CHKERRQ(ierr);
  ierr = VecDestroy(&X);CHKERRQ(ierr);
  ierr = DMDestroy(&dm);CHKERRQ(ierr);
  ierr = PetscFinalize();
  return(0);
}
