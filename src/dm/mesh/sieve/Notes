Concepts.
-----------
Because of the use of templating and generic programming techniques,
many fundamental ALE types cannot be defined by making progressively specific 
class declarations within a given hierarchy. Instead, they must satisfy certain
Concept requirements that make them acceptable inputs to various Algorithms.
This reflects a shortcoming of the current compiler technology that some defining
features of Concepts have to be specified in documentation, rather than within the 
language.  Sometimes, however, conceptual types can be viewed as themselves 
encapsulating Algorithms acting on other types implementing certain concepts.
This allows to define the structure of these algorithmic types using generic 
programming techniques available in C++, for example.


Atlas & Sec
-----------------------
In the past we have considered the Atlas concept, which, for the given
Sifter, chart and ind types computed the assignment of indices
to the points in the underlying Sieve (relative to a given chart).
This mimics a system of local coordinate systems on a manifold or some
such space. 

Essentially, Atlas can be thought of as a Sifter, with the 
underlying Sifter's points (base or cap?) in the cap, charts in the base
and indices being the color on the edges.  However, any type that responds
to the fundamental requests -- setting the number of indices over a point 
(fiber dimension), (re)ordering the indices after some dimension modifications
have been made, and retrieving the indices -- is an Atlas.

An object that assigns data of a given type to the (point, chart) pairs of an Atlas 
is called its section or Sec.  If an Atlas is viewed as a discrete model of a structure
bundle over the point space, a Sec is a discrete model of a section of that bundle.
Sec is required to define a restrict method, which, given a (point,chart) pair returns
a data iterator.  

If the Sifter underling the Atlas is a Sieve, we assume that to each
covering arrow p --> q (within the same chart), corresponds a mapping of the data d(p) <-- d(q),
reflecting the idea that d(q) can be 'restricted' to d(p) within the same chart (or perhaps 
in any chart?).  This sort of behavior is certainly impossible to guarantee through
an interface specification, but it remains a conceptual requirement on Sec that 
the data over p are somehow "included" in the data over q.  This "inclusion" is partly specified
in the Atlas (e.g., by ensuring that the indices over p are included in those over q),
and partly in Sec itself.


Map & ParMap concepts.
-----------------------
A Map is thought of as a type of mapping from a Sec class to another Sec class.
Maps and ParMaps can be viewed as algorithmic types acting on the input/output Sec types.  
Most importantly, a Map must advertise the Atlases of the input and output Sec
types.  Furthermore, a Map acts essentially as a Sec relative to the output
atlas: giving a fixed input Sec S, a Map extends the Sec interface by defining restrictions 
to output  (point,chart) pairs relative to S.  Alternatively, a Map can return an output Sec T,
containing the result of applying the map to S, which can be queried independently.

With these features of a Map hardly define any implementation structure (rather an interface), 
since the particular behavior of restrictions is unconstrained by this specification.  
Particular Maps can impose further constraints on the input/output atlases
and expand the interface, so long as they conform to the Map concept outlined above.
For example, we can require that each output chart data depend only on the explicitly specified 
input charts' data.  This is done by specifying the 'lightcone' Sifter or a Sieve, connecting 
the input charts to the output charts they depend on.  Taking the cone (or the closure, if it's 
a Sieve) of a given output chart in the lightcone returns all of the input charts necessary
to compute the data over the output chart.

The specification of a Map's lightcone is very necessary to enable preallocation of internal 
data structures, such as the matrix storage, for linear maps.  In the distributed context
it also enables the setup of communication structures.  This behavior is encapsulated in 
a ParMap, which is itself a conceptual type that extends Map.  ParMap encapsulates (among other things) 
three conceptual Map objects: Gather,Scatter and the Transform. A ParMap is then an algorithm that orchestrates 
the action of other maps.

***
  The ParMap algorithm is a most clear illustration of the locazation principle underlying Sieves and computation over
them: restrict-compute-assemble.  To compute the action of a ParMap on a distributed Sec the necessary data must be
communicate to and from the processes requiring and holding the data.  The total overlap of a processes domain with the
rest of the communicator is naturally covered by the individual overlaps indexed by the remote ranks. 
  To communicate the local input Sec data to the remote processes, the Sec is first restricted to each of the overlap pieces, 
forming another Sec, whose charts are the overlaps indexed by indices, and whose points are the (in_point,in_chart)
pairs on which in the input Sec is defined.  This Sec can be viewed as multisheeted coverings of the overlap porition
of the input Sec, and the multiplexing process forming the new Sec will be called Scatter.  It is a map between two Secs
with the input atlas and the new rank-indexed atlas.
  After Scatter maps the input Sec to a multisheeted covering, the multisheeted data are communicated to the processes according
to the rank in each chart. This can be viewed as a map between two such Secs -- communication is certainly a mapping in
the distributed context -- done 'locally' over each chart.  Thus, the data from the input Sec are first localized onto
each rank-chart, then mapped, and finally must be assembled. 
  To obtain a Sec over the local domain, the Scatter process must be reversed, using the a map called Gather.  Gather
takes in the multisheeted covering of the overlap obtained after the communication phase, and obtains a single
(in_point,in_chart) data point from the collection of all such points over all the rank charts.  During this reduction
the overlap portion of the communicated input Sec is unified with the local data over the same (in_point,in_chart) pair,
completing the assembly of the input Sec.
  Once the input data have been communicate to the consuming processes, Transform locally maps the data from the input
Sec to the output Sec.  The Gather/Scatter maps involved in the communication stage depend on the GatherAtlas, which
describes the multisheeted covering of InAtlas.  Gather/Scatter maps can in principle operate on a Sec of any Atlas,
unifying the data over the same point in different charts, producing a Sec over a single-charted atlas.  Different
implementations of Gather/Scatter lead to different multiplexing/reduction procedures, while the atlas structure stays
the same.  Gather/Scatter maps can be used locally as well and need not act on the result of a communication.
***

The Gather output atlas has the same structure as the ParMap input atlas,
while the Gather input atlas  -- GatherAtlas -- combines the ParMap input (point,chart) pairs into 
the source and puts the communicator rank in the target. The Scatter input/output atlases have the 
structure of the output/input atlases of Gather respectively. The Transform atlases have the same 
structure as the ParMap atlases.
                  (Gather input)                  (Gather output == Transform input)            
                                       
                          index                            index                       
            (point,chart) -----> rank     <==>       point -----> chart   

                  (Scatter output)                (Scatter input == Transform input)            

GatherAtlas is constructed from ParMap's input atlas using the lightcone.
The Gather input/Scatter output atlas essentially applies the idea of a chart recursively:
Transform input charts are distributed among different processes.  Given a single process, its overlap
with other processes can be indexed by their remote communicator ranks.  All (point_in,chart_in) pairs shared
with a given rank are part of a single rank-chart.  This way a single in-chart is "blown up"
into a "multisheeted" covering by rank-charts; each (point_in,chart_in) pair becomes a rank-point within 
one or many rank-charts.  

The data over this rank-atlas are essentially the data in the send/receive buffers,
and the Scatter map is responsible for (multiplexing) packing and moving the data from the input Sec into the rank-Sec 
encapsulating these buffers. Once this has been done, ParMap executes the communication code (send/recv),
and the rank-multisheeted data are transfered to the required processes.  

                                    Scatter                                     send/recv
                                                                   ... rank_0
             point_in --> chart_in    ==>      (point_in,chart_in) --> rank_k      ==> 
                                                                   ... rank_K

Then Gather reduces the data over a single (point_in,chart_in) pair in all of the rank-charts.  This can be thought 
of as gluing all of the partial sections over the overlaps with remote processes into a single "remote" Sec and then
gluing it with the "local" Sec.  Once the remote data have been assimilated into the local input Sec, Transform does
its thing.


                                     rank_0    Gather                        Transform
                                ...
            (point_in,chart_in) -->  rank_n     ==>    point_in --> chart_in    ==>      point_out --> chart_out
                                ...
                                     rank_N

Observe that the structure of the GatherAtlas is essentially the same as the structure of the
Overlap Sifter in ParDelta, therefore the Overlap code can be reused.  However, that code is not customizable,
while we may want to allow the GatherAtlas  constructor the flexibility to massage the atlas (e.g., to keep only 
s single rank for a given (point,chart) pair, thereby implementing the 'owner' concept).  Making GatherAtlas a class
a class will allow this flexibility by exposing the input atlas computation method to overloading.
The prototypical GatherAtlas object will be implemented to keep all of the ranks in the remote overlap under
a given (point_in, chart_in) pair.  Custom GatherAtlas objects may prune that so that the number and amount
of data sent/recv'd by ParMap is only as required.  Here we assume that the overlap is small and computed only once
or infrequently, while ParMap mappings are frequent.

             
            