<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
</head>


<body>

<div style="text-align: center;"><big><big><span style="font-weight: bold;">TOPS Solver Component</span></big></big>

      

    <br>

</div>

<br>

The TOPS Solver Component (TSC) is a <a href="http://www.llnl.gov/CASC/components">Babel/SIDL</a> based <a href="http://www.cca-forum.org">CCA</a>
compliant HPC software component (henceforth shortened to CCA
component). It provides easy, direct access to virtually all of the
<a href="http://www.tops-scidac.org">TOPS</a> (as well as many other) linear and nonlinear algebraic solvers (a
partial list may be found <a href="http://www-unix.mcs.anl.gov/petsc/petsc-as/documentation/linearsolvertable.html">here</a>).<br>

<br>

The application developer interacts with the TOPS.Solver component
by constructing a CCA component that implements the TOPS.System
interface and one or more problem specific interfaces. This "System"
component completely defines the algebraic system to be
solved. The TOPS.Solver and the "System" component then collaborate
to solve one or more algebraic problems. Complex applications will likely
also couple several additional CCA components.<br>

<br>

This is rather abstract, so we present several explicit examples:<br>

<br>

The first is the classic Bratu problem&nbsp;discretized with
finite differences on a regular grid in two dimensions. The application
code consists of the SIDL definition of our the "System" component

  <br>

<br>
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
package Ex1 version 0.0.0 {class System implements-all TOPS.System, TOPS.SystemComputeResidual {
    }
  }</span><span style="color: rgb(51, 51, 255); font-family: monospace;">

</span><br style="color: rgb(51, 51, 255); font-family: monospace;">

<br>

and the code that defines the nonlinear equation<br>

<br>
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
void
Ex1::System_impl::computeResidual (
  /* in */ ::sidl::array</span><double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;"> x,
  /* in */ ::sidl::array</span><double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;"> f) 
throw (){
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.begin(Ex1.System.computeResidual)</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">&nbsp;TOPS::Solver_Structured solver = this-&gt;solver;
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int xs = f.lower(0);            // first grid point in X and Y directions on this process
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int ys = f.lower(1);
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int xm = f.length(0) - 1;       // number of local grid points in X and Y directions on this process
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int ym = f.length(1) - 1;</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int i,j;
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int mx = solver.getDimensionX();
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">int my = solver.getDimensionY();

  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">double hx     = 1.0/(double)(mx-1);
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">double hy     = 1.0/(double)(my-1);
  <br>
double sc     = hx*hy;
  <br>
double hxdhy  = hx/hy; 
  <br>
double hydhx  = hy/hx;
 
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">/*
     Compute function over the locally owned part of the grid
  */
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">&nbsp; for (j=ys; j&lt;ys+ym; j++) {<br>
&nbsp;&nbsp;&nbsp; for (i=xs; i&lt;xs+xm; i++) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i == 0 || j == 0 || i == mx-1 || j == my-1) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.set(i,j,x.get(i,j));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = x.get(i,j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double uxx&nbsp;&nbsp;&nbsp;&nbsp; = (2.0*u - x.get(i-1,j) - x.get(i+1,j))*hydhx;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double uyy&nbsp;&nbsp;&nbsp;&nbsp; = (2.0*u - x.get(i,j-1) - x.get(i,j+1))*hxdhy;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.set(i,j,uxx + uyy - sc*exp(u));<br>
&nbsp; &nbsp; &nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp; }&nbsp; <br>
&nbsp; // DO-NOT-DELETE splicer.end(Ex1.System.computeResidual)<br>
}</span><span style="font-style: italic; color: rgb(51, 51, 255);"></span><br>
<br>
The next example is a version of the driven cavity; this is a
multicomponent PDE again solved on a structured grid. The SIDL is
identical to that above.<br>
We also need to tell the Tops.Solver that it is solving a multicomponent problem with four components (in Ex2_System_Impl.cc)<br>
<br>
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">void ex2::system_impl::initializeOnce throw (){ </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">//&nbsp;</span></double></double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">DO-NOT-DELETE splicer.begin(Ex2.System.initializeOnce)</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<double><double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">this-&gt;</span><ys +ym="" j="" {="" for="" (i="xs;" i=""><xs +xm="" if="" (i="=" 0="" i="" mx-1="" |="" j="=" my-1="" f.set(i,j,x.get(i,j="" else="" u="x.get(i,j);" uxx="(2.0*u" x.get(i-1,j="" x.get(i+1,j))*hydhx="" double="" x.get(i,j-1="" x.get(i,j+1))*hxdhy="" f.set(i,j,uxx="" +="" uyy="(2.0*u" -="" sc*exp(u="" splicer.end(ex1.system.computeresidual="" }="" next="" driven="" cavity="" sidl="" identical="" example="" above="" difference="" in="" component="" implementation="" simply="" routine="" to="" tell="" the="" tops.solver="" that="" it="" is="" solving="" a="" multicomponent="" problem="" with="" four="" components="" void="" ex2::system_impl::initializeonce="" throw="" (="" {="" do-not-delete="" splicer.begin(ex2.system.initializeonce="" this=""><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">solver.setBlockSize(4);
  </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.end(Ex2.System.initializeOnce)
</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">}</span><br>
<br>
&nbsp;and define several PDE parameters (in Ex2_System_Impl.hh)<br>
<br>
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.begin(Ex2.System._implementation)
    </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">TOPS::Solver_Structured solver;
    </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">double
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grashof, prandtl, lid; </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.end(Ex2.System._implementation)

   </span><br style="font-style: italic;">
<br>
initialize them (</xs></ys></double></double>in Ex2_System_Impl.cc)<br>
<br>
<double><double><ys +ym="" j="" {="" for="" (i="xs;" i=""><xs +xm="" if="" (i="=" 0="" i="" mx-1="" |="" j="=" my-1="" f.set(i,j,x.get(i,j="" else="" u="x.get(i,j);" uxx="(2.0*u" x.get(i-1,j="" x.get(i+1,j))*hydhx="" double="" x.get(i,j-1="" x.get(i,j+1))*hxdhy="" f.set(i,j,uxx="" +="" uyy="(2.0*u" -="" sc*exp(u="" splicer.end(ex1.system.computeresidual="" }="" next="" driven="" cavity="" sidl="" identical="" example="" above="" difference="" in="" component="" implementation="" simply="" routine="" to="" tell="" the="" tops.solver="" that="" it="" is="" solving="" a="" multicomponent="" problem="" with="" four="" components="" void="" ex2::system_impl::initializeonce="" throw="" (="" {="" do-not-delete="" splicer.begin(ex2.system.initializeonce="" this=""><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">void Ex2::System_impl::_ctor() {
     </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.begin(Ex2.System._ctor)</span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">this-&gt;lid     = 0.0;
     this-&gt;prandtl = 1.0;
     this-&gt;grashof = 1.0;
     </span><br style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
<span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">// DO-NOT-DELETE splicer.end(Ex2.System._ctor)
   }</span><br>
<br>
One can also provide a nonzero initial guess to the solver by
inheriting from&nbsp;TOPS.SystemComputeInitialGuess using SIDL such as<br>
<br>
</xs></ys></double></double><span style="font-style: italic; color: rgb(51, 51, 255); font-family: monospace;">
package Ex2 version 0.0.0 {class System implements-all TOPS.System, TOPS.SystemComputeResidual, TOPS.SystemComputeInitialGuess {
    }
  }</span><span style="color: rgb(51, 51, 255); font-family: monospace;">

</span><double><double><ys +ym="" j="" {="" for="" (i="xs;" i=""><xs +xm="" if="" (i="=" 0="" i="" mx-1="" |="" j="=" my-1="" f.set(i,j,x.get(i,j="" else="" u="x.get(i,j);" uxx="(2.0*u" x.get(i-1,j="" x.get(i+1,j))*hydhx="" double="" x.get(i,j-1="" x.get(i,j+1))*hxdhy="" f.set(i,j,uxx="" +="" uyy="(2.0*u" -="" sc*exp(u="" splicer.end(ex1.system.computeresidual="" }="" next="" driven="" cavity="" sidl="" identical="" example="" above="" difference="" in="" component="" implementation="" simply="" routine="" to="" tell="" the="" tops.solver="" that="" it="" is="" solving="" a="" multicomponent="" problem="" with="" four="" components="" void="" ex2::system_impl::initializeonce="" throw="" (="" {="" do-not-delete="" splicer.begin(ex2.system.initializeonce="" this=""><span style="font-family: monospace;">&nbsp;</span><br>
<br>
and providing code like (in Ex2_System_Impl.cc)<br>
<br>
<span style="color: rgb(51, 51, 255); font-family: monospace;">void Ex2::System_impl::computeInitialGuess (&nbsp;/* in */ ::sidl::array&lt;double&gt; x ) throw () {</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; // DO-NOT-DELETE splicer.begin(Ex2.System.computeInitialGuess)</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; /*</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; Compute initial guess over the locally owned part of the grid</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp; Initial condition is motionless fluid and equilibrium temperature</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; */</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; TOPS::Solver_Structured solver = this-&gt;solver;</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; int xs = x.lower(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // first grid point in X and Y directions on this process</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; int ys = x.lower(2);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;
int xm = x.length(1) - 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // number
of local grid points in X and Y directions on this process</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; int ym = x.length(2) - 1;</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; int i,j;</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; double dx&nbsp; = 1.0/(solver.getDimensionX()-1);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; double grashof = this-&gt;grashof;&nbsp; </span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; for (j=ys; j&lt;ys+ym; j++) {</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp; for (i=xs; i&lt;xs+xm; i++) {</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.set(U,i,j,0.0);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.set(V,i,j,0.0);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.set(OMEGA,i,j,0.0);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.set(TEMP,i,j,(grashof&gt;0)*i*dx);</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp;&nbsp;&nbsp; }</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; }</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">&nbsp; // DO-NOT-DELETE splicer.end(Ex2.System.computeInitialGuess)</span><br style="color: rgb(51, 51, 255); font-family: monospace;">
<span style="color: rgb(51, 51, 255); font-family: monospace;">}</span><br>
<br>
Next we give the simple Poisson problem in 3 dimensions again on a
structured grid, with zero Dirichlet boundary conditions. The SIDL code
is<br>
<br>
<br>
<br>
<br>
<span style="color: rgb(255, 0, 0);">This is all very confusing and
counter intuitive. I want to pass a matrix and a vector to the solver,
why do I have to provide functions</span><br style="color: rgb(255, 0, 0);">
<span style="color: rgb(255, 0, 0);">that compute the matrix and the vector? <br>
<br>
<span style="color: rgb(0, 0, 0);">For solvers to be efficient, they must be in control of where and when the systems are generated.</span><br style="color: rgb(255, 0, 0);">
</span>




   
</xs></ys></double></double>
</body>
</html>
