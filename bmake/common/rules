# $Id: rules,v 1.203.1.111.1.125 2001/08/22 17:57:34 balay Exp $ 
#
#
# Checks that PETSC_DIR variable is set and creates library directory
# if it does not exist
chkpetsc_dir:
	@mypwd=`pwd`; cd ${PETSC_DIR} 2>&1 > /dev/null; true_PETSC_DIR=`pwd`; cd $${mypwd} 2>&1 >/dev/null; \
        newpwd=`echo $${mypwd} | sed "s+$${true_PETSC_DIR}+DUMMY+g"`;\
        haspetsc=`echo $${mypwd} | sed "s+petsc-+DUMMY+g"`;\
        if [ $${mypwd} = $${newpwd} -a $${haspetsc} != $${mypwd} ]; then \
          echo "*********************** ERROR ************************" ; \
          echo "Your PETSC_DIR does not match the directory you are in";\
          echo "******************************************************" ; \
        fi

chklib_dir:
	@if [ ${BOPT}foo = foo ] ; then \
	  echo "*********************** ERROR ************************" ; \
	  echo "You must use the make variable BOPT=[g,O,O_c++,O_complex,...]" ; \
	  echo "For example, use: make BOPT=g ex1"; \
          echo "Remove all .o files and rerun make with appropriate BOPT"; \
	  echo "******************************************************";  false; fi
	@if [ ! -d "${INSTALL_LIB_DIR}" ]; then \
	  echo Making directory ${INSTALL_LIB_DIR} for library; ${MKDIR} ${INSTALL_LIB_DIR} ; fi

# 1. Checks that user has set BOPT variable
# 2. Check if the ${INSTALL_LIB_DIR} exists
chkopts_basic: 
	@if [ ${BOPT}foo = foo ] ; then \
	  echo "*********************** ERROR ************************" ; \
	  echo "You must set the variable BOPT=[g,O,O_c++,O_complex,...]" ; \
	  echo "For exampe, use: make BOPT=g ex1"; \
          echo "Remove all .o files and rerun make with appropriate BOPT"; \
	  echo "******************************************************" ; \
          false; fi
	@if [ ${BOPT}foo = 0foo ]; then \
	  echo "*********************** ERROR ************************" ; \
          echo "BOPT should be the letter O_c++ not the digit zero_c++"; \
	  echo "******************************************************" ; \
          false; fi
	@if [ "${BOPT}foo" = "0_c++foo" ]; then \
	  echo "*********************** ERROR ************************" ; \
          echo "BOPT should be the letter O not the digit zero"; \
	  echo "******************************************************" ; \
          false; fi
	@if [ ! -d ${INSTALL_LIB_DIR} ]; then \
	  echo "*********************** ERROR ************************" ; \
	  echo Libraries not built for this BOPT: ${BOPT}; \
	  echo "******************************************************" ;\
          false ; fi

# 3. Check if the shared libs are out of date
chkopts: chkopts_basic
	@for LIBNAME in ${SHLIBS}; do \
	if test -z "${LIBTOOL}"; then \
	  library=${INSTALL_LIB_DIR}/$$LIBNAME.a; \
	else \
	  library=${INSTALL_LIB_DIR}/lt_$$LIBNAME.a; \
	fi; \
	sharedlibrary=${INSTALL_LIB_DIR}/$$LIBNAME.${SLSUFFIX}; \
	flag=""; \
	if [ -f $$library ]; then \
	  if [ -f $$sharedlibrary ]; then \
	    flag=`find ${INSTALL_LIB_DIR} -type f -name $$LIBNAME.a -newer $$sharedlibrary -print`; \
	  fi; \
	fi; \
	if [ "$$flag" != "" ]; then \
	  echo "Shared libs in ${INSTALL_LIB_DIR} are out of date, attempting to rebuild."; \
	  if [ -w ${INSTALL_LIB_DIR} ]; then \
	    ${OMAKE} BOPT=${BOPT} PETSC_ARCH=${PETSC_ARCH} shared; \
	  else \
	    echo "*********************** ERROR ************************"; \
	    echo "Unable to rebuild shared libraries; you do not have write permission."; \
	    user=`ls -l ${INSTALL_LIB_DIR}/$$LIBNAME.${SLSUFFIX}  | tr -s ' ' | cut -d ' ' -f 3`; \
	    echo "Libraries were built by user $$user; please contact him/her to have them rebuilt."; \
	    echo "******************************************************"; \
	    false; \
	  fi; \
	fi; \
	done

# Does nothing; needed for some rules that require actions.
foo:

# Builds library
lib: chklib_dir  ${SOURCE}
	@${OMAKE}  PETSC_ARCH=${PETSC_ARCH} BOPT=${BOPT} chkpetsc_dir
	@-if [ "${SPECIALLIB}" = "yes" ] ; then \
	   ${OMAKE}  PETSC_ARCH=${PETSC_ARCH} BOPT=${BOPT} speciallib;  \
	  else \
            if [ "${SOURCEC}" != "" ] ; then \
              ${OMAKE}  PETSC_ARCH=${PETSC_ARCH} BOPT=${BOPT} libc; fi ; \
            if [ "${SOURCEF}" != "" ] ; then \
		${OMAKE}  PETSC_ARCH=${PETSC_ARCH} BOPT=${BOPT} libf; fi ; \
            if [ "${OBJS}" != " " ] ; then \
		${RANLIB}  ${LIBNAME}; \
		${RM} ${OBJS}; \
	    fi;\
          fi
#
#  Does not work for some machines with .F fortran files.
#
# Builds library - fast version

libfast: chklib_dir ${SOURCEC} ${SOURCEF}
	-@if [ "${SPECIALFASTLIB}" = "yes" ] ; then \
	    ${OMAKE}  PETSC_ARCH=${PETSC_ARCH} BOPT=${BOPT} specialfastlib;  \
	else \
	if [ "${SOURCEC}" != "" ]; then \
	        if test -n "${LIBTOOL}"; then \
                    ${PETSC_COMPILE_LIBTOOL}; \
	            ${AR} ${AR_FLAGS} ${LIBNAME} ${OBJSC} ${SOBJS}; \
	            ${AR} ${AR_FLAGS} ${LT_LIBNAME} ${OBJSC:.o=.lo} ${SOBJS:.o=.lo}; \
	            ${RM} ${OBJSC} ${SOBJS} ${OBJSC:.o=.lo} ${SOBJS:.o=.lo}; \
	        else \
                    ${PETSC_COMPILE}; \
	            ${AR} ${AR_FLAGS} ${LIBNAME} ${OBJSC} ${SOBJS}; \
	            ${RM} ${OBJSC} ${SOBJS}; \
	        fi; \
	    fi; \
	fi

# Removes garbage files
clean:
	@-${RM} *.o *.lo *~ ex[0-9] ex[0-9][0-9] ex[0-9]f ex[0-9][0-9]f \
	       ${CLEANFILES} ${TESTS} ex[0-9]f90 ex[0-9][0-9]f90 ex[0-9]c ex[0-9][0-9]c ex[0-9]d ex5d \
	       PI* *.ln l.outa* mputil.mp_* core core.* *.tmp *.map gmon.out \
	       trashz \#*\# *.mex* *.stolen *.trace Log.* joe jeff *.stolen \
	       output/*~ .mpirtmp mon.out *.aus *.mon.* __* p4pg ins10*.c \
	       ex[0-9].exe ex[0-9][0-9].exe ex[0-9]f.exe ex[0-9][0-9]f.exe \
	       *.ad.c *.ad.h ad_deriv.h .adic* *.cp_ *.cp__ *.c*.c pageform.txt \
               .adic* *.dep *.proj ctoatmp PETScArena* *.L *.anl main *.mod .mpi* \
	       *.class *.ouit *.ad.* g_* silly.cmp *.tmp.* *.ilk *.pdb
	@-${RM} -rf output.* AD_cache

cleanadic:
	@-${RM} *.ad.*
#
#   Compiles all the directories on which a particular external package depends. This way
#  one can update PETSc for an external package without recompiling all of PETSc
#
package:
	@-for dir in ${${PACKAGE}_DIRS} ; do \
           r=`egrep requirespackage $$dir/makefile`; \
           if [ "$$?" = 0 ]; then \
	     HCONF=`grep PETSC_ ${PETSC_DIR}/bmake/${PETSC_ARCH}/petscconf.h | cut -d" " -f2`; \
             HPCONF=`echo ${PCONF} | sed s/-D//g`; \
             f=0; \
             for l in $${HPCONF} foo $${HCONF}; do \
               echo $$r | egrep "'$$l'" > /dev/null; \
               if [ "$$?" = 0 ]; then \
	         f=1; \
                 break; \
               fi; \
             done ; \
             if [ "$$f" = 0 ]; then \
                continue; \
             fi; \
           fi; \
           r=`egrep requireslanguage $$dir/makefile`; \
           if [ "$$?" = 0 ]; then \
             echo $$r | egrep ${PETSC_LANGUAGE} > /dev/null; \
             if [ "$$?" = 1 ]; then \
               continue; \
             fi; \
           fi; \
           r=`egrep requiresscalar $$dir/makefile`; \
           if [ "$$?" = 0 ]; then \
             echo $$r |  egrep ${PETSC_SCALAR} > /dev/null; \
             if [ "$$?" = 1 ]; then \
               continue; \
             fi; \
           fi; \
           r=`egrep requiresprecision $$dir/makefile`; \
           if [ "$$?" = 0 ]; then \
             echo $$r |  egrep ${PETSC_PRECISION} > /dev/null; \
             if [ "$$?" = 1 ]; then \
               continue; \
             fi; \
           fi; \
           pushd $$dir; \
           ${OMAKE} tree ACTION=libfast BOPT=${BOPT} PETSC_ARCH=${PETSC_ARCH} LOC=${LOC}; \
           popd; \
        done;
#
#  Checks if directory requires particular package or language
# The makefile may contain
#    #requirespackage 'PETSC_HAVE_XXX' 
#    #requireslanguage CONLY (or CPP)
#    #requiresscalar   real (or complex)
#    #requiresprecision double (or single)
#
tree: ${ACTION}
	-@if [ "${DIRS}" != "" ]; then \
	  for dir in ${DIRS} foo ; do \
            if [ "$$dir" = "fortran" -a "${C_FLINKER}foo" = "foo" ]; then \
              continue;\
            fi;\
            if [ -d $$dir ]; then \
	      r=`egrep requirespackage $$dir/makefile`; \
              if [ "$$?" = 0 ]; then \
		HCONF=`grep PETSC_ ${PETSC_DIR}/bmake/${PETSC_ARCH}/petscconf.h | cut -d" " -f2`; \
                HPCONF=`echo ${PCONF} | sed s/-D//g`; \
                f=0; \
                for l in $${HPCONF} foo $${HCONF}; do \
                  echo $$r | egrep "'$$l'" > /dev/null; \
                  if [ "$$?" = 0 ]; then \
	            f=1; \
                    break; \
                  fi; \
                done ; \
                if [ "$$f" = 0 ]; then \
                  continue; \
                fi; \
              fi; \
              r=`egrep requireslanguage $$dir/makefile`; \
              if [ "$$?" = 0 ]; then \
                echo $$r | egrep ${PETSC_LANGUAGE} > /dev/null; \
                if [ "$$?" = 1 ]; then \
                  continue; \
                fi; \
              fi; \
              r=`egrep requiresscalar $$dir/makefile`; \
              if [ "$$?" = 0 ]; then \
                echo $$r |  egrep ${PETSC_SCALAR} > /dev/null; \
                if [ "$$?" = 1 ]; then \
                  continue; \
                fi; \
              fi; \
              r=`egrep requiresprecision $$dir/makefile`; \
              if [ "$$?" = 0 ]; then \
                echo $$r |  egrep ${PETSC_PRECISION} > /dev/null; \
                if [ "$$?" = 1 ]; then \
                  continue; \
                fi; \
              fi; \
            else \
              continue; \
            fi; \
            (cd $$dir ; \
            echo ${ACTION} in: `pwd`; \
            ${OMAKE} tree ACTION=${ACTION} BOPT=${BOPT} PETSC_ARCH=${PETSC_ARCH} LOC=${LOC} DATAFILESPATH=${DATAFILESPATH});\
	  done ; \
        fi

# Performs the specified action throughout the directory tree
tree_basic: ${ACTION}
	@-if [ "${DIRS}" != "" ]; then \
	for dir in ${DIRS} foo ; do if [ -d $$dir ]; then \
	(cd $$dir ; echo ${ACTION} in: `pwd`; \
	${OMAKE}  tree_basic ACTION=${ACTION} BOPT=${BOPT} \
	PETSC_ARCH=${PETSC_ARCH}  LOC=${LOC}) ;fi; \
	done ; fi

#This target goes through all the dirs that contains a makefile
alltree_makefile: ${ACTION}
	-@DIRS=`ls`; \
	for dir in $$DIRS foo ; do if [ -f $$dir/makefile ]; then \
	(cd $$dir ; echo ${ACTION} in: `pwd`; \
	${OMAKE}  alltree_makefile ACTION=${ACTION} BOPT=${BOPT} \
	PETSC_ARCH=${PETSC_ARCH} LOC=${LOC} ) ;fi; \
	done
# This target goes through all dirs specified by DIRS,EDIRS, and 
# excludes dirs specified by $XDIRS
alltree: ${ACTION}
	@-if [ "${DIRS} ${EDIRS}" != " " ]; then \
	NDIRS="${DIRS} ${EDIRS}" ;\
	if [ "${XDIRS}" != "" ]; then \
	for XDIR in ${XDIRS} qwertyuiop ; do \
	NDIRS=`echo $$NDIRS | sed s/$$XDIR//g`; \
	done; fi ; \
	for dir in $$NDIRS foo ; do if [ -d $$dir ]; then \
	(cd $$dir ; echo ${ACTION} in: `pwd`; \
	${OMAKE}  alltree ACTION=${ACTION} BOPT=${BOPT} \
	PETSC_ARCH=${PETSC_ARCH} LOC=${LOC} ) ;fi; \
	done ; fi

getlinklibs:
	-@echo  ${C_SH_LIB_PATH} ${PETSC_TS_LIB}

getincludedirs:
	-@echo  ${PETSC_INCLUDE}

getmpilinklibs:
	-@echo  ${MPI_LIB}

getmpiincludedirs:
	-@echo  ${MPI_INCLUDE}

getmpirun:
	-@echo  ${MPIRUN}

etags_sourcec:
	-@if [ "${SOURCEC}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${SOURCEC} ; fi
etags_sourcej:
	-@if [ "${SOURCEJ}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${SOURCEJ} ; fi
etags_sourceh:
	-@if [ "${SOURCEH}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${SOURCEH}; fi
etags_sourcef:
	-@if [ "${SOURCEF}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${SOURCEF}; fi
etags_docs:
	-@if [ "${DOCS}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${DOCS}; fi
etags_bmakefiles:
	-@if [ "${BMAKEFILES}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${BMAKEFILES}; fi
etags_examplesc:
	-@if [ "${EXAMPLESC}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${EXAMPLESC}; fi
etags_examplesch:
	-@if [ "${EXAMPLESCH}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${EXAMPLESCH}; fi
etags_examplesf:
	-@if [ "${EXAMPLESF}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${EXAMPLESF}; fi
etags_examplesfh:
	-@if [ "${EXAMPLESFH}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${EXAMPLESFH}; fi
etags_makefile:
	-@etags -a -f ${TAGSFILE} makefile
etags_scripts:
	-@if [ "${SCRIPTS}" != "" ]; then \
		etags -a -f ${TAGSFILE} ${SCRIPTS}; fi

# --------------------------------------------------------------------
#
# All remaining actions are intended for PETSc developers only.
# PETSc users should not generally need to use these commands.
#
#
# External tools required for HMTL version of source
C2HTML   = c2html

# Builds Fortran-77 wrappers 
fortranstubs:
	@-${BFORT} -dir ${PETSC_DIR}/src/fortran/auto \
	  -mnative -ansi -nomsgs -anyname -mapptr -mpi -ferr -ptrprefix Petsc\
	  -ptr64 PETSC_USE_POINTER_CONVERSION  -fcaps PETSC_HAVE_FORTRAN_CAPS \
          -fuscore PETSC_HAVE_FORTRAN_UNDERSCORE ${SOURCEC}

.SUFFIXES: .F  .F90 .f90 ${SUFFIXES} .PETSc .C .cc .cpp .r .rm .so .html .ad .m

#
#
.c.o .cpp.o .cc.o .C.o .ad.o: 
	@mypwd=`pwd`; newpwd=`echo $${mypwd} | sed "s+/examples/tutorials+DUMMY+g"`;\
        if [ $${mypwd} != $${newpwd} ]; then \
	  ${OMAKE}  PETSC_ARCH=${PETSC_ARCH} BOPT=${BOPT} chkpetsc_dir;\
        fi
	-@complex=`echo ${PETSCFLAGS} |grep PETSC_USE_COMPLEX`; \
        if [ "${PETSC_HAVE_ADIC}" = "" ]; then \
          egrep PETSC_HAVE_ADIC ${PETSC_DIR}/bmake/${PETSC_ARCH}/petscconf.h > /dev/null;\
          if [ "$$?" = 0 ]; then \
            haveadic=1; \
          else \
            haveadic=0;\
          fi; \
        else \
          haveadic=1; \
        fi; \
	if [ "$${haveadic}" = "1" -a  "foo$${complex}" = "foo" ]; then \
	   egrep "Process adiC" $< > /dev/null ; \
              if [ "$$?" = 0 ]; then \
                c=`grep "Process adiC" $< | sed -e "s?[ ]*Process adiC(\([0-9]*\)): [a-zA-Z0-9 ]*?\1?g"`;\
                r=`grep "Process adiC" $< | sed -e "s?[ ]*Process adiC([0-9]*): \([a-zA-Z0-9 ]*\)?\1?g"`;\
                echo Running adiC on function $${r};\
                ${PETSC_DIR}/bin/adprocess.py $< $${r}; \
	        echo '#include "petscda.h"' > $*.ad.c ; \
	        echo '#include "petscsnes.h"' >> $*.ad.c ;\
	        echo '#define ad_GRAD_MAX ' $${c} >> $*.ad.c ;\
                echo ${ADIC_CC}  -i ${PETSC_DIR}/bmake/adic.init $<.tmp; \
	        ${ADIC_CC} -t -i ${PETSC_DIR}/bmake/adic.init  $<.tmp ; \
	        cat $<.ad.tmp  >> $*.ad.c ;\
	        ${ADIC_CC} -t -h -i ${PETSC_DIR}/bmake/adicmf.init   $<.tmp ; \
	        egrep "main\(" $< > /dev/null ; \
                if [ "$$?" = 0 ]; then \
		      echo "#include \"${PETSC_DIR}/src/sys/src/adic/Gradient/ad_grad.c\"" >> $*.ad.c ;\
	  	      echo "#include \"${PETSC_DIR}/src/sys/src/adic/Gradient/ad_utils.c\"" >> $*.ad.c ;\
                fi;\
                echo "#undef ad_GRAD_MAX" >> $*.ad.c ;\
                echo "#define ad_GRAD_MAX 1"  >> $*.ad.c ;\
                echo "typedef struct {double value;double  grad[1];} mfDERIV_TYPE;"  >> $*.ad.c ;\
	        sed -e "s/DERIV_TYPE/mfDERIV_TYPE/g" $<.ad.tmp >> $*.ad.c ;\
	        echo "#include \"$<\"" >> $*.ad.c ;\
		${RM} ad_deriv.h ; \
	        echo ${CC} -o $*.o -c ${ADIC_DEFINES} -I${PETSC_DIR}/include/adic  ${COPTFLAGS} ${CFLAGS} ${CCPPFLAGS} $*.ad.c ;\
	        ${CC} -o $*.o -c ${ADIC_DEFINES} -I${PETSC_DIR}/include/adic  ${COPTFLAGS} ${CFLAGS} ${CCPPFLAGS} $*.ad.c ;\
              else \
	        echo ${PETSC_COMPILE_SINGLE} $<; \
	        ${PETSC_COMPILE_SINGLE} $<; \
              fi; \
        elif  [ -f $*.ad.c ]; then \
          echo ${CC} -o $*.o  -c ${ADIC_DEFINES} -I${PETSC_DIR}/include/adic ${COPTFLAGS} ${CFLAGS} ${CCPPFLAGS} $*.ad.c ;\
	  ${CC} -o $*.o -c ${ADIC_DEFINES} -I${PETSC_DIR}/include/adic  ${COPTFLAGS} ${CFLAGS} ${CCPPFLAGS} $*.ad.c ;\
        else \
	  echo ${PETSC_COMPILE_SINGLE} $<; \
	  ${PETSC_COMPILE_SINGLE} $<; \
        fi

.c.a .cpp.a .cc.a .C.a: 
	-${PETSC_COMPILE_SINGLE} $<
	-${AR} ${AR_FLAGS} ${LIBNAME} $*.o
	-if test -n "${LIBTOOL}"; then ${AR} ${AR_FLAGS} ${LT_LIBNAME} $*.lo; fi
	-${RM} $*.o $*.lo

#
#  These rules are for compiling the test examples.
#
.cpp.rm .cc.rm .C.rm .F.rm .f.rm .c.rm:
	-@${RM} $* *.o $*.mon.* gmon.out mon.out
.c.PETSc:
	-@${OMAKE}  PETSC_ARCH=${PETSC_ARCH} BOPT=${BOPT} $* > trashz 2>&1
	-@grep -v clog trashz | grep -v "information sections" | \
          grep -v "WARNING: TOC" | \
          grep -v "D4024 : unrecognized" | \
          grep -v "Extra instructions" | \
          grep -v "Unused external reference" | \
          grep -v "f90 continuing despite warning messages" | \
          grep -v "symbol if the" | \
          grep -v "ignoring symbol version info" | \
          grep -v "preempts that definition" | \
          grep -v "is an array from" | \
	  grep -v "At least one PA 2.0" | \
          grep -v "Cannot cast" | \
          grep -v "WARNING 134: weak definition of" | \
          grep -v "Warning(s) detected" | \
          grep -v "object file assumed" | \
          grep -v "consider using mkstemp"  |\
          grep -v EXTERNAL  |\
          grep -v "warning prebinding disabled"  |\
          grep -v volatile  |\
          grep -v -i inconsistent |\
          grep -v Anachronism | \
	  egrep -i '(Error|warning|Can|Unresolved)' >> /dev/null;\
	  if [ "$$?" != 1 ]; then \
          echo "--------------Error detected during compile or link!-----------------------";\
          echo "See http://www.mcs.anl.gov/petsc/petsc-2/documentation/troubleshooting.html";\
	  cat trashz ; fi; ${RM} trashz
.F.PETSc:
	-@${OMAKE}  PETSC_ARCH=${PETSC_ARCH} BOPT=${BOPT} $* > trashz 2>&1
	-@grep -v EXTERNAL trashz | grep -v Wall | \
          grep -v "Unused external reference" | \
          grep -v "D4024 : unrecognized" | \
          grep -v "WARNING: TOC overflow." | \
          grep -v "Extra instructions are being" | \
          grep -v "symbol if the symbol" | \
          grep -v -i inconsistent | \
          grep -v -i "unused dummy" | \
	  grep -v "WARNING:  -cpp is ignored" | \
          grep -v "ignoring symbol version info" | \
	  grep -v "At least one PA 2.0" | \
	  grep -v "Inconsistent structure" | \
          grep -v "object file assumed" | \
	  grep -v "ex20.F:30:" | \
	  grep -v "ex20f.F:31: warning" | \
	  grep -v "f90 continuing despite warning messages" | \
          grep -v "is an array from" | \
          grep -v "consider using mkstemp"  |\
	  grep -v "Unused external reference" | \
          grep -v "WARNING 134: weak definition of" | \
          grep -v 'continuing despite warning messages' | \
          grep -v "warning prebinding disabled"  |\
	  grep -v "Unused dummy argument" | \
          grep -v "warning multiple definitions of symbol _matgetarray_" | \
	  egrep -i '(Error|warning|Can|Unresolved)'  >> /dev/null ; \
	  if [ "$$?" != 1 ]; then \
          echo "--------------Error detected during compile or link!-----------------------";\
          echo "See http://www.mcs.anl.gov/petsc/petsc-2/documentation/troubleshooting.html";\
	  cat trashz ; fi; ${RM} trashz;


deleteshared: chkopts_basic
	${RM} ${INSTALL_LIB_DIR}/*.${SLSUFFIX} ${INSTALL_LIB_DIR}/so_locations

noshared:
# ---------------------------------------------------------------------------------------
#   Rules for the automatic generation of documentation, tutorials etc
# See rule for allmanualpages and allhtml in ${PETSC_DIR}/makefile 
#
# Builds manual pages in HTML in two stages
#   1.) manualpages_buildcite: builds the file manualpages.cit for hyperlinks
#   2.) manualpages: builds the html pages, complete with hyperlinks

chk_manualpage_dir:
	@if [ ! -d "${LOC}/docs/manualpages/${MANSEC}" ]; then \
	  echo Making directory ${LOC}/docs/manualpages/${MANSEC} for library; ${MKDIR} ${LOC}/docs/manualpages/${MANSEC}; fi

manualpages_buildcite: chk_manualpage_dir
	@-if [ "${MANSEC}" != "" ] ; then \
	  DOCTEXT_PATH=${PETSC_DIR}/docs/tex/doctext; \
	  TEXTFILTER_PATH=${PETSC_DIR}/docs/tex/doctext; \
          ${DOCTEXT} -html -indexdir ../${MANSEC} \
		-index ${LOC}/docs/manualpages/manualpages.cit \
		-mpath ${LOC}/docs/manualpages/${MANSEC} ${SOURCEC} ${SOURCEH};  fi 
#
#
manualpages:
	-@if [ "${MANSEC}" != "" ] ; then \
	  DOCTEXT_PATH=${PETSC_DIR}/docs/tex/doctext; \
	  ${DOCTEXT} -html \
		-mpath ${LOC}/docs/manualpages/${MANSEC} -heading PETSc \
		-defn ${PETSC_DIR}/docs/tex/doctext/html.def \
		-locdir ${LOCDIR} -mapref ${LOC}/docs/manualpages/manualpages.cit \
		${SOURCEC} ${SOURCEH}; \
		chmod -f g+w ${LOC}/docs/manualpages/${MANSEC}/* ; fi 
#
#   Example usage for manual pages; adds each example that uses a function to that functions
# manual page up to a limit of 10 examples.
#
manexamples:
	-@base=`basename ${LOCDIR}`; \
        if [ "$${base}" = "tutorials" ] ; then \
          echo "Generating manual example links" ; \
          for i in ${EXAMPLESC} ${EXAMPLESF} foo ; do \
            if [ "$$i" != "foo" ] ; then \
              a=`cat $$i | ${MAPNAMES} -map ${LOC}/docs/manualpages/manualpages.cit \
                   -printmatch -o /dev/null | sort | uniq` ;  \
              for j in $$a ; do \
                b=`ls ${LOC}/docs/manualpages/*/$${j}.html | cut -f9` ; \
                l=`grep tutorials $${b} | wc -l`; \
                if [ $$l -le 10 ] ; then \
                  if [ $$l -eq 0 ] ; then \
                    echo "<P><H3><FONT COLOR=\"#CC3333\">Examples</FONT></H3>" >> $$b; \
                  fi; \
                  echo  "<A HREF=\"../../../BB\">BB</A><BR>" | sed s?BB?${LOCDIR}$$i.html?g >> $$b; \
                  grep -v /BODY $$b > ltmp; \
                  echo "</BODY></HTML>" >> ltmp; \
                  mv -f ltmp $$b; \
                fi; \
              done; \
            fi; \
	  done; \
        fi

#
#   Goes through all examples adding the Concepts: to the /tmp/exampleconcepts file
#
exampleconcepts:
	-@base=`basename ${LOCDIR}`; \
        if [ "$${base}" = "tutorials" ] ; then \
          echo "Generating concepts list" ; \
          for i in ${EXAMPLESC} ${EXAMPLESF} foo ; do \
            if [ "$$i" != "foo" ] ; then \
              grep Concepts: $$i | sed -e s?Concepts:??g -e s?\!??g > ltmp;  \
              line=`cat ltmp | wc -l`; \
              line=`expr $$line - 1` ; \
              line=`expr $$line + 1` ; \
              while [ $$line -gt 0 ] ; do \
                a=`head -$$line ltmp | tail -1`; \
                echo ${LOCDIR}$$i $$a >> ${LOC}/docs/tex/exampleconcepts; \
                line=`expr $$line - 1` ; \
              done; \
              ${RM} ltmp; \
            fi; \
	  done; \
        fi
#
#   Goes through all manual pages removing the Concepts: field and adding the 
# concepts to the /tmp/manconcepts file
#
manconcepts:
	-@${RM} ${LOC}/docs/tex/manconcepts ${LOC}/docs/tex/exampleconcepts
	-@for i in docs/manualpages/*/*.html ; do \
              ${RM} ltmp; \
              grep Concepts: $$i | sed s?Concepts:??g > ltmp;  \
              line=`cat ltmp | wc -l`; \
              line=`expr $$line - 1` ; \
              line=`expr $$line + 1` ; \
              if [ $$line -gt 0 ] ; then \
                while [ $$line -gt 0 ] ; do \
                  a=`head -$$line ltmp | tail -1`; \
                  echo $$i $$a >> ${LOC}/docs/tex/manconcepts; \
                  line=`expr $$line - 1` ; \
                done; \
                grep -v Concepts: $$i > tmp; \
                mv tmp $$i; \
              fi; \
              ${RM} ltmp; \
          done

getexlist:
	-@${PETSC_DIR}/maint/getexlist -locdir ${LOCDIR} -byfile -destdir ${LOC}/docs/manualpages/concepts/ ${EXAMPLESC} ${EXAMPLESF}
	-@${RM} -f logfile.txt
#
#   Rules for generating html code from C and Fortran 
#	
checkmakefilelist:
	-@ls makefile ${SOURCEC} ${SOURCEF} ${SOURCEH} ${EXAMPLESC} ${EXAMPLESF} ${EXAMPLESCH} ${EXAMPLESFH} ${EXAMPLESMATLAB} 2>/dev/null | grep -v \\.\\. |  sort | uniq > /tmp/$$USER.$$.make ;\
	ls makefile *.c *.h *.F *.m *.h90 2>/dev/null | sort | uniq > /tmp/$$USER.$$.ls; \
	diff /tmp/$$USER.$$.make  /tmp/$$USER.$$.ls; \
	${RM}  /tmp/$$USER.$$.make  /tmp/$$USER.$$.ls

html:
	-@sed -e s?man+../?man+ROOT/docs/manualpages/? ${LOC}/docs/manualpages/manualpages.cit > /tmp/$$USER.htmlmap
	-@cat ${PETSC_DIR}/docs/mpi.www.index >> /tmp/$$USER.htmlmap
	-@ROOT=`echo ${LOCDIR} | sed -e s?/[a-z]*?/..?g -e s?src/??g -e s?include/??g` ;\
          loc=`pwd | sed -e s?\$${PETSC_DIR}?$${LOC}/?g -e s?/disks??g`;  \
          for i in ${SOURCEC} ${SOURCEF} ${SOURCEH} ${EXAMPLESC} ${EXAMPLESF} ${EXAMPLESCH} ${EXAMPLESFH} ${EXAMPLESMATLAB} foo ; do\
	    if [ -f $$i ]; then \
              iroot=`echo $$i | sed -e s?[a-z.]*/??g`;\
              IROOT=`echo $${i} | sed -e s?[.][.]??g` ;\
              if [ "$${IROOT}" != "$${i}" ] ; then \
                IROOT=".."; \
              else \
                IROOT=$${ROOT};\
              fi;\
              ${RM} $${loc}/$$i.html; \
              echo "<center><a href=\"$${iroot}\">Actual source code: $${iroot}</a></center><br>" > $${loc}/$$i.html; \
              cat $$i | sed -e "s/CHKERRQ(ierr);//g" -e "s/PetscFunctionReturn(0)/return(0)/g"  \
              -e "s/ierr [ ]*= //g"   | ${C2HTML} -n  | ${PETSC_DIR}/maint/fixinclude $$i $${ROOT} | \
              grep -v PetscValid | grep -v PetscFunctionBegin | grep -v PetscCheck | grep -v "int ierr;" |\
              grep -v '#if !defined(__' | grep -v '#define __' | grep -v '#undef __' | \
              ${MAPNAMES} -map /tmp/$$USER.htmlmap -inhtml | sed -e s?ROOT?$${IROOT}?g >> $${loc}/$$i.html ; \
	    fi; \
         done
	-@ROOT=`echo ${LOCDIR} | sed -e s?/[a-z]*?/..?g -e s?src/??g -e s?include/??g` ;\
          loc=`pwd | sed -e s?\$${PETSC_DIR}?$${LOC}/?g -e s?/disks??g`; ${RM} $${loc}/index.html; \
          cat ${PETSC_DIR}/docs/manualpages/sec/header_${MANSEC} | sed -e "s?<A HREF=\"PETSC_DIR[a-z/]*\">Examples</A>?<A HREF=\"$${ROOT}/docs/manualpages/${MANSEC}\">Manual pages</A>?g" -e "s?PETSC_DIR?$${ROOT}/?g"> $${loc}/index.html; \
          echo "<p>" >> $${loc}/index.html
	-@loc=`pwd | sed -e s?\$${PETSC_DIR}?$${LOC}/?g -e s?/disks??g`;\
            if [ "${EXAMPLESC}" != "" ] ; then \
               for file in ${EXAMPLESC} foo ; do \
		if [ -f $$file ]; then \
                   cmess=`grep "static char help" $${file} | cut -d\" -f2 | cut -d\. -f1`; \
                   echo "<a href=\"$${file}.html\">$${file}: $${cmess}</a><br>" >> $${loc}/index.html;\
		fi; \
               done ;\
            else \
               for file in ${DIRS} foo; do \
		 if [ -d $$file ]; then \
                   echo "<a href=\"$${file}/\">$${file}/</a><br>" >> $${loc}/index.html; \
		 fi; \
               done; \
               echo " " >> $${loc}/index.html; \
               for file in ${SOURCEH} ${SOURCEC} ${SOURCEF} foo ; do \
		 if [ -f $$file ]; then \
                   echo "<a href=\"$${file}.html\">$${file}</a><br>" >> $${loc}/index.html; \
		 fi; \
               done; \
            fi ;\
            echo " " >> $${loc}/index.html; \
            echo "<a href=\"makefile.html\">makefile</a><br>" >> $${loc}/index.html
	-@loc=`pwd | sed -e s?\$${PETSC_DIR}?$${LOC}/?g -e s?/disks??g`;  \
	   cat makefile | ${C2HTML}  | ${MAPNAMES} -map /tmp/$$USER.htmlmap -inhtml > $${loc}/makefile.html
	-@${RM} /tmp/$$USER.htmlmap tmp

cleanhtml:
	-@${RM} makefile.html *.c.html *.F.html *.h.html *.h90.html index.html *.m.html

# -------------------------------------------------------------------------------
#
#   Rule for generating ADIC derivatives from PETSc .c and .hfiles
#
adic:
	@-if [ "${NOADIC}" != "true" ]; then if [ "${SOURCEC}" != "" ]; then \
          for i in ${SOURCEC} foo; do if [ -f $$i ]; then \
          ${ADIC_CC} -s -h -f 1 ${CFLAGS} ${CCPPFLAGS} $$i ; \
          fi; done ; \
        fi; fi
	@-if [ "${NOADIC}" != "true" ]; then if [ "${SOURCEH}" != "" ]; then \
          for i in ${SOURCEH} foo; do if [ -f $$i ]; then \
          ${ADIC_CC} -s -h -f 1 ${CFLAGS} ${CCPPFLAGS} $$i ; \
          fi; done ; \
        fi; fi
	-@chmod -f go+rw *.ad.*

adic2:
	-if [ "${NOADIC}" != "true" ]; then if [ "${SOURCEC}" != "" ]; then \
          for i in ${SOURCEC} foo; do if [ -f $$i ]; then \
          ${ADIC_CC} -h -f 1 ${CFLAGS} ${CCPPFLAGS} $$i ; \
          fi; done ; \
        fi; fi
	-if [ "${NOADIC}" != "true" ]; then if [ "${SOURCEH}" != "" ]; then \
          for i in ${SOURCEH} foo; do if [ -f $$i ]; then \
          ${ADIC_CC} -h -f 1 ${CFLAGS} ${CCPPFLAGS} $$i ; \
          fi; done ; \
        fi; fi
	-@chmod -f go+rw *.ad.*

adiclib:
	-@if [ "${NOADIC}" != "true" ]; then if [ "${SOURCEC}" != "" ]; then \
          ${CC} -c ${COPTFLAGS} ${CFLAGS} ${CCPPFLAGS} ${ADIC_INCLUDE} *.ad.c ; \
        fi; fi
	-@if [ "${NOADIC}" != "true" ]; then if [ "${SOURCEC}" != "" ]; then \
          ${AR} ${AR_FLAGS} ${INSTALL_LIB_DIR}/${LIBBASE}.a *.ad.o ; \
        fi; fi
	-@chmod -f go+rw ${INSTALL_LIB_DIR}/${LIBBASE}.a
	-@${RM} *.ad.o

adiclib2:
	-if [ "${NOADIC}" != "true" ]; then if [ "${SOURCEC}" != "" ]; then \
          ${CC} -c ${COPTFLAGS} ${CFLAGS} ${CCPPFLAGS} ${ADIC_INCLUDE} *.ad.c ; \
        fi; fi
	-if [ "${NOADIC}" != "true" ]; then if [ "${SOURCEC}" != "" ]; then \
          ${AR} ${AR_FLAGS} ${INSTALL_LIB_DIR}/${LIBBASE}.a *.ad.o ; \
        fi; fi
	-@chmod -f go+rw ${INSTALL_LIB_DIR}/${LIBBASE}.a
	-@${RM} *.ad.o
# ----------------------------------------------------------------------------------------
# Rules for finding errors in the source and errors in the coding style
#
countfunctions: chklib_dir
	-@if [ ! -f ${INSTALL_LIB_DIR}/countfunctions ]; then \
	  touch ${INSTALL_LIB_DIR}/countfunctions ; fi
	@-if [ "${SOURCEC}" != "" ]; then \
          for i in ${SOURCEC} foo; do if [ -f $$i ]; then \
           grep "define __FUNCT__" $$i | cut -f2 -d\" >> ${INSTALL_LIB_DIR}/countfunctions ; \
          fi; done ; \
        fi

checkbadPetscFunctionBegin:
	-@if [ "${SOURCEC}" != "" ] ; then \
	${OMAKE}  PETSC_ARCH=${PETSC_ARCH} BOPT=${BOPT} \
	checkbadPetscFunctionBegin_private ; fi

checkbadPetscFunctionBegin_private:
	-@for filename in ${SOURCEC} ; do \
	a=`grep '#define __FUNCT__' $$filename | wc -l`; \
	b=`grep 'PetscFunctionBegin' $$filename | wc -l`; \
	if [ $$a -ne $$b ] ; then \
	echo "$$filename: __FUNCT__ = $$a; PetscFunctionBegin = $$b" ; \
	fi; \
	done

checkbadFileHeader:
	-@for filename in ${SOURCEC} makefile ${SOURCEH} ${SOURCEF} ${EXAMPLESC} ${EXAMPLESF}; do \
	a=`grep 'Id:' $$filename | wc -l`; \
	if [ $$a -ne 1 ] ; then \
	echo "$$filename: missing RCS file header" ; \
	fi; \
	done

checkbadSource:
	-@for filename in ${SOURCEC} makefile ${SOURCEH} ${SOURCEF} ${EXAMPLESC} ${EXAMPLESF}; do \
       a=`grep '( ' $$filename | wc -l`; \
       if [ $$a -ge 1 ] ; then \
       echo "$$filename: extra blank after (" ; \
       fi; \
       a=`grep ' )' $$filename | wc -l`; \
       if [ $$a -ge 1 ] ; then \
       echo "$$filename: extra blank before )" ; \
       fi; \
         a=`grep 'register int' $$filename | wc -l`; \
       if [ $$a -ge 1 ] ; then \
       echo "$$filename: do not use register keyword in PETSc" ; \
       fi; \
         a=`grep 'register double' $$filename | wc -l`; \
       if [ $$a -ge 1 ] ; then \
       echo "$$filename: do not use register keyword in PETSc" ; \
       fi; \
         a=`grep '; CHK' $$filename | wc -l`; \
       if [ $$a -ge 1 ] ; then \
       echo "$$filename: space before CHKERRx() or CHKPTRx()" ; \
       fi; \
         done

checkTestCoverage:
	-@for filename in ex*.c; do \
	  if test -f $$filename; then \
	    if ! grep run`basename $$filename .c`\: makefile 2>&1 > /dev/null; then \
	      echo "Missing run target for `pwd`/$$filename"; \
	    elif ! grep run`basename $$filename .c`\  makefile 2>&1 > /dev/null; then \
	      echo "Missing test for `pwd`/$$filename"; \
	    fi; \
	  fi; \
	done
	-@for filename in ex*.f; do \
	  if test -f $$filename; then \
	    if ! grep run`basename $$filename .f`\: makefile 2>&1 > /dev/null; then \
	      echo "Missing run target for `pwd`/$$filename"; \
	    elif ! grep run`basename $$filename .f`\  makefile 2>&1 > /dev/null; then \
	      echo "Missing test for `pwd`/$$filename"; \
	    fi; \
	  fi; \
	done
	-@for filename in ex*.F; do \
	  if test -f $$filename; then \
	    if ! grep run`basename $$filename .F`\: makefile 2>&1 > /dev/null; then \
	      echo "Missing run target for `pwd`/$$filename"; \
	    elif ! grep run`basename $$filename .F`\  makefile 2>&1 > /dev/null; then \
	      echo "Missing test for `pwd`/$$filename"; \
	    fi; \
	  fi; \
	done
	-@for filename in ex*.f90; do \
	  if test -f $$filename; then \
	    if ! grep run`basename $$filename .f90`\: makefile 2>&1 > /dev/null; then \
	      echo "Missing run target for `pwd`/$$filename"; \
	    elif ! grep run`basename $$filename .f90`\  makefile 2>&1 > /dev/null; then \
	      echo "Missing test for `pwd`/$$filename"; \
	    fi; \
	  fi; \
	done

#
# fixfortran target is used in one of the stages of generating the fortran
# interface stubs - in src/fortran/auto
#

fixfortran:
	@echo "Fixing pointers in src/fortran/auto"
	-@for FILENAME in ${SOURCEC} ; do \
	  if [ ! -f $$FILENAME ]; then \
	    echo "Error: file $$FILENAME specified in SOURCEC does not exist."; \
	  else \
	    cat $$FILENAME | \
	    sed "s/__ierr/ierr/g" | \
	    sed "s/^void /void PETSC_STDCALL /" | \
	    sed "s/PetscToPointer(int)/PetscToPointer(void *)/" | \
	    sed "s/PetscRmPointer(int)/PetscRmPointer(void *)/" | \
	    sed "s/PetscToPointer(a) (a)/PetscToPointer(a) (*(long *)(a))/" | \
	    sed "s/PetscFromPointer(a) (int)(a)/PetscFromPointer(a) (long)(a)/" | \
	    sed "s/PetscToPointer( \*(int\*)/PetscToPointer( /" | \
	    sed "s/MPI_Comm comm/MPI_Comm *comm/" | \
	    sed "s/(MPI_Comm)PetscToPointer( (comm) )/(MPI_Comm)MPI_Comm_f2c(*(MPI_Fint*)(comm))/" | \
	    sed -f ${PETSC_DIR}/bmake/common/sedcmdforfortranstubs > _$$FILENAME; \
	    /bin/mv _$$FILENAME $$FILENAME ;\
	  fi; \
	done

citool:
	-@bk citool
	-@cd ${PETSC_DIR}/python/BuildSystem; bk citool

pull:
	-@bk pull
	-@cd ${PETSC_DIR}/python/BuildSystem; bk pull

push:
	-@bk push
	-@cd ${PETSC_DIR}/python/BuildSystem; bk push


#
#   Updates your PETSc version to the latest set of patches
#
update:
	-@if [ -d ${PETSC_DIR}/BitKeeper ]; then \
          echo "Using BK to update source code" ; \
          ${OMAKE} PETSC_DIR=${PETSC_DIR} PETSC_ARCH=${PETSC_ARCH} pull ;\
          echo " ";\
          echo "You may need to run ** make allfortranstubs ** to update the Fortran interfaces";\
          echo " ";\
        else \
          which python > /dev/null 2>1;  \
          if [ "$$?" != "0" ]; then \
            echo "Automatic update requires Python in your path";\
            echo "See http://www.mcs.anl.gov/petsc/petsc-2/download/petsc-patches.html";\
          else \
            echo "Using patch to update source code" ;  \
	    ${PETSC_DIR}/bin/update.py ${UPDATE_OPTIONS};\
          fi;\
        fi



include ${PETSC_DIR}/bmake/${PETSC_ARCH}/rules



