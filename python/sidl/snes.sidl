package PETSc {
  interface PetscObject {
    // Get the implementation type
    string getType();
    // Set the implementation type
    void setType(in string typeName);

    // Get the prefix appended to options directed to this object
    string getOptionsPrefix();
    // Set the prefix appended to options directed to this object
    void setOptionsPrefix(in string prefix);
    // Enlarge the prefix appended to options directed to this object
    void appendOptionsPrefix(in string prefix);
    // Customize this object using command line arguments
    void setFromOptions();

    // Initiate the object setup phase
    void setUp();

    // Output a representation of the object using 
    void view(in PETSc.PetscViewer viewer);
  }

  class Base implements PetscObject {
    // Initialize PETSc
    static void Initialize();
    // Finalize PETSc
    static void Finalize();

    // Check whether PETSc has been initialized
    static bool Initialized();
    // Check whether PETSc has been finalized
    static bool Finalized();
  }

  class PetscViewer implements PetscObject {
  }

  class PetscMap implements PetscObject {
    // Get the size of the locally-owned portion
    void getLocalSize(out int localSize);
    // Set the size of the locally-owned portion
    void setLocalSize(in int localSize);
    // Get the total size
    void getSize(out int size);
    // Set the total size
    void setSize(in int size);
    // Get the half-open interval of local indices
    void getLocalRange(out int start, out int end);
    // Get the ranges for all processors (range[rank] <= local index < range[rank+1])
    void getGlobalRange(out array<int> range);
  }

  enum NormType {NORM_1, NORM_2, NORM_FROBENIUS, NORM_INFINITY, NORM_1_AND_2};

  enum InsertMode {NOT_SET_VALUES, INSERT_VALUES, ADD_VALUES, MAX_VALUES};

  class Vec implements PetscObject {
    // Set the local and global storage sizes
    void setSizes(in int n, in int N);
    // result = y^H self
    void dot(in Vec y, out double result);
    // result = y^T self
    void tDot(in Vec y, out double result);
    // result = ||self||
    void norm(in NormType normType, out double result);
    // result = ||self|| and vector is normalized
    void normalize(out double result);
    // result = \sum_i self_i
    void sum(out double result);
    // Returns the maximum "value", which is found at index "position"
    void max(out int position, out double value);
    // Returns the minimum "value", which is found at index "position"
    void min(out int position, out double value);
    // self_i = self_i * value
    void scale(in double value);
    // Copy self into y
    void copy(in Vec y);
    // self_i = value
    // ERROR: NOT CHANGED IN PETSc YET
    void set(in double value);
    // Swap the values in self and y
    void swap(in Vec y);
    // self_i = a * x_i + self_i
    // ERROR: NOT CHANGED IN PETSc YET
    void AXPY(in double a, in Vec x);  
    // self_i = x_i + a * self_i
    void AYPX(in double a, in Vec x);
    // self_i = a * x_i + b * self_i
    void AXPBY(in double a, in double b, in Vec x);
    // self_i = \sum_i a_i x_i + self_i
    void MAXPY(in array<double> a, in array<Vec> x);
    // self_i = a x_i + y_i
    void WAXPY(in double a, in Vec x, in Vec y);
    // self_i = max(x_i, y_i)
    void pointwiseMax(in Vec x, in Vec y);
    // self_i = max(|x_i|, |y_i|)
    void pointwiseMaxAbs(in Vec x, in Vec y);
    // self_i = min(x_i, y_i)
    void pointwiseMin(in Vec x, in Vec y);
    // self_i = x_i y_i
    void pointwiseMult(in Vec x, in Vec y);
    // self_i = x_i / y_i
    void pointwiseDivide(in Vec x, in Vec y);
    // result = max_i |x_i / y_i|
    void maxPointwiseDivide(in Vec y, out double result);
    // self_i = self_i + value
    void shift(in double value);
    // self_i = 1 / self_i
    void reciprocal();
    // self_i = \sqrt{self_i}
    void sqrt();
    // self_i = |self_i|
    void abs();
    // Duplicates the vector (does not copy values)
    void duplicate(out Vec dup);          
    // Return the layout of the vector
    void getPetscMap(out PetscMap map);
    // Set values into the vector
    void setValues(in array<int> indices, in array<double> values, in InsertMode mode);
    // Start parallel assembly
    void assemblyBegin();
    // Finish parallel assembly
    void assemblyEnd();
    // Get the block size
    void getBlockSize(out int size);
    // Set the block size
    void setBlockSize(in int size);
    // Set values into the vector
    void setValuesBlocked(in array<int> indices, in array<double> values, in InsertMode mode);
    // Get the local storage
    void getArray(out array<double> values);
    // Return the local storage
    void restoreArray(inout array<double> values);
    // result = (self == y)
    void equal(in Vec y, out bool result);
  }

  class Mat implements PetscObject {
    // Set the local and global number of rows and columns
    void setSizes(in int m, in int n, in int M, in int N);
  }

  enum MatStructure {SAME_NONZERO_PATTERN, DIFFERENT_NONZERO_PATTERN, SAME_PRECONDITIONER, SUBSET_NONZERO_PATTERN};

  //   enum ConvergedReason {KSP_CONVERGED_ITERATING = 0,
  //               KSP_CONVERGED_ATOL               =  3,
  //               KSP_CONVERGED_RTOL               =  2,
  //               KSP_CONVERGED_ITS                =  4,
  //               KSP_CONVERGED_QCG_NEG_CURVE      =  5,
  //               KSP_CONVERGED_QCG_CONSTRAINED    =  6,
  //               KSP_CONVERGED_STEP_LENGTH        =  7,
  //               KSP_DIVERGED_NULL                = -2,
  //               KSP_DIVERGED_ITS                 = -3,
  //               KSP_DIVERGED_DTOL                = -4,
  //               KSP_DIVERGED_BREAKDOWN           = -5,
  //               KSP_DIVERGED_BREAKDOWN_BICG      = -6,
  //               KSP_DIVERGED_NONSYMMETRIC        = -7,
  //               KSP_DIVERGED_INDEFINITE_PC       = -8,
  //               KSP_DIVERGED_NAN                 = -9,
  //               KSP_DIVERGED_INDEFINITE_MAT      = -10};
  class KSP implements PetscObject {
  }

  class PC implements PetscObject {
  }

  // Convergence
  //   SNES_CONVERGED_ITERATING      still iterating
  //   SNES_CONVERGED_FNORM_ABS      F < F_minabs
  //   SNES_CONVERGED_FNORM_RELATIVE F < F_mintol*F_initial
  //   SNES_CONVERGED_PNORM_RELATIVE step size small
  //   SNES_CONVERGED_TR_DELTA       trust region tol???
  // Divergence
  //   SNES_DIVERGED_FUNCTION_COUNT  too many function evaluations
  //   SNES_DIVERGED_FNORM_NAN       encountered NaN in residual
  //   SNES_DIVERGED_MAX_IT          too many iterations
  //   SNES_DIVERGED_LS_FAILURE      line search did not produce descent
  //   SNES_DIVERGED_LOCAL_MIN       || J^T b || is small, implies converged to local minimum of F()
  enum SNESConvergedReason {SNES_CONVERGED_ITERATING = 0, SNES_CONVERGED_FNORM_ABS = 2, SNES_CONVERGED_FNORM_RELATIVE = 3,
                            SNES_CONVERGED_PNORM_RELATIVE = 4, SNES_CONVERGED_TR_DELTA = 7,
                            SNES_DIVERGED_FUNCTION_COUNT = -2, SNES_DIVERGED_FNORM_NAN = -4, SNES_DIVERGED_MAX_IT = -5,
                            SNES_DIVERGED_LS_FAILURE = -6, SNES_DIVERGED_LOCAL_MIN = -8};


  class SNES implements PetscObject {
    // Retrieve the linear solver
    PETSc.KSP getKSP();

    // Get the function which calculates the residual F
    void getFunction(out PETSc.Vec f, out function func);
    // Set the function which calculates the residual F
    void setFunction(in PETSc.Vec f, in function func);
    // Get the function which calculates the Jacobian J
    void getJacobian(out PETSc.Mat J, out PETSc.Mat M, out function func);
    // Set the function which calculates the jacobian J
    void setJacobian(in PETSc.Mat J, in PETSc.Mat M, in function jacobian);

    // Compute the residual F(x)
    void computeFunction(in PETSc.Vec x, in PETSc.Vec f);
    // Compute the jacobian J(x)
    void computeJacobian(in PETSc.Vec x, out PETSc.Mat J, out PETSc.Mat M, out PETSc.MatStructure flag);

    // Get the solver tolerances:
    //   absolute residual tolerance
    //   relative residual tolerance
    //   absolute solution update tolerance
    //   maximum iteration count
    //   maximum function evaluation count
    void getTolerances(out double abstol, out double rtol, out double stol, out int maxit, out int maxf);
    // Set the solver tolerances:
    //   absolute residual tolerance
    //   relative residual tolerance
    //   absolute solution update tolerance
    //   maximum iteration count
    //   maximum function evaluation count
    void setTolerances(in double abstol, in double rtol, in double stol, in int maxit, in int maxf);

    // Solve the system of nonlinear algebraic equations
    void solve(in PETSc.Vec b, in PETSc.Vec x);
    // Get the solution vector
    PETSc.Vec getSolution();
    // Get the reason for termination of the solver
    SNESConvergedReason getConvergedReason();
    // Get the number of solver iterates
    int getIterationNumber();
    // Get the residual norm
    double getFunctionNorm();
  }
}