package PETSc {
  interface PetscObject {
    // Get the implementation type
    string getType();
    // Set the implementation type
    void setType(in string typeName);

    // Get the object name
    string getName();
    // Set the object name
    void setName(in string name);

    // Get the prefix appended to options directed to this object
    string getOptionsPrefix();
    // Set the prefix appended to options directed to this object
    void setOptionsPrefix(in string prefix);
    // Enlarge the prefix appended to options directed to this object
    void appendOptionsPrefix(in string prefix);

    // Configure the object using the PETSc options database
    void setFromOptions();
    // Initiate the object setup phase
    void setUp();

    // Output a representation of the object using 
    void view(in PETSc.PetscViewer viewer);

    // Get the PETSc object pointer
    opaque getObject();
    // Set the PETSc object pointer
    void setObject(in opaque object);
  }

  class Base implements PetscObject {
    // Initialize PETSc
    static void Initialize();
    // Finalize PETSc
    static void Finalize();

    // Check whether PETSc has been initialized
    static bool Initialized();
    // Check whether PETSc has been finalized
    static bool Finalized();
  }

  class PetscLog implements PetscObject {
    static void stageRegister(out int stage, in string stageName);
    static void stagePush(in int stage);
    static void stagePop();
    static void eventRegister(out int event, in string eventName, in int cookie);
    static void eventBegin(in int event);
    static void eventEnd(in int event);
    static void flops(in int flops);
  }

  class PetscOptions implements PetscObject {
    // Determines whether a certain option is given in the database
    static bool hasName(in string pre, in string name);
    // Sets an option name-value pair in the options database, overriding whatever is already present
    static void setValue(in string name, in string value);
    // Clears an option name-value pair in the options database, overriding whatever is already present
    static void clearValue(in string name);

    static void getInt(in string pre, in string name, out int value, out bool flag);
    static void getReal(in string pre, in string name, out double value, out bool flag);
    static void getScalar(in string pre, in string name, out double value, out bool flag);
    static void getTruth(in string pre, in string name, out bool value, out bool flag);
  }

  enum PetscConstants {PETSC_IGNORE = 0, PETSC_DECIDE = -1, PETSC_DEFAULT = -2};

  enum PetscViewerFormat {PETSC_VIEWER_ASCII_DEFAULT, PETSC_VIEWER_ASCII_MATLAB, PETSC_VIEWER_ASCII_MATHEMATICA,
      PETSC_VIEWER_ASCII_IMPL, PETSC_VIEWER_ASCII_INFO, PETSC_VIEWER_ASCII_INFO_DETAIL, PETSC_VIEWER_ASCII_COMMON,
      PETSC_VIEWER_ASCII_SYMMODU, PETSC_VIEWER_ASCII_INDEX, PETSC_VIEWER_ASCII_DENSE, PETSC_VIEWER_BINARY_DEFAULT,
      PETSC_VIEWER_BINARY_NATIVE, PETSC_VIEWER_DRAW_BASIC, PETSC_VIEWER_DRAW_LG, PETSC_VIEWER_DRAW_CONTOUR,
      PETSC_VIEWER_DRAW_PORTS, PETSC_VIEWER_NATIVE, PETSC_VIEWER_NOFORMAT, PETSC_VIEWER_ASCII_FACTOR_INFO};

  enum PetscViewerFileType {PETSC_FILE_RDONLY, PETSC_FILE_WRONLY, PETSC_FILE_CREATE};

  interface PetscViewer extends PetscObject {
    // Get the filename associated with the viewer
    string getFilename();
    // Set the filename associated with the viewer
    void setFilename(in string filename);
    // Get the viewer file type
    PetscViewerFileType getFileType();
    // Set the viewer file type
    void setFileType(in PetscViewerFileType fileType);
    // Get the current format (top of the format stack)
    PetscViewerFormat getFormat();
    // Set the current format (top of the format stack)
    void setFormat(in PetscViewerFormat format);
    // Push a format onto the format stack
    void pushFormat(in PetscViewerFormat format);
    // Pop the current format from the format stack
    void popFormat();
    // Flush the output stream
    void flush();
  }

  class PetscViewerBinary implements PetscViewer {
    // Get the associated file descriptor
    int getDescriptor();
    // Prevent creation of a .info file
    void skipInfo();
    // Load options from the .info file if it exists
    void loadInfo();
    // Return the flag indicating whether the options databse is used when recreating objects in the file
    bool getSkipOptions();
    // Set the flag indicating whether the options databse is used when recreating objects in the file
    void setSkipOptions(in bool skipOptions);
  }

  class PetscMap implements PetscObject {
    // Get the size of the locally-owned portion
    int getLocalSize();
    // Set the size of the locally-owned portion
    void setLocalSize(in int localSize);
    // Get the total size
    int getSize();
    // Set the total size
    void setSize(in int size);
    // Get the half-open interval of local indices
    void getLocalRange(out int start, out int end);
    // Get the ranges for all processors (range[rank] <= local index < range[rank+1])
    array<int>:range getGlobalRange();
  }

  enum NormType {NORM_1, NORM_2, NORM_FROBENIUS, NORM_INFINITY, NORM_1_AND_2};

  enum InsertMode {NOT_SET_VALUES, INSERT_VALUES, ADD_VALUES, MAX_VALUES};

  class Vec implements PetscObject {
    // Set the local and global storage sizes
    void setSizes(in int n, in int N);
    // result = y^H self
    double dot(in Vec y);
    // result = y^T self
    double tDot(in Vec y);
    // result = ||self||
    double norm(in NormType normType);
    // result = ||self|| and vector is normalized
    double normalize();
    // result = \sum_i self_i
    double sum();
    // Returns the maximum "value", which is found at index "position"
    void max(out int position, out double value);
    // Returns the minimum "value", which is found at index "position"
    void min(out int position, out double value);
    // self_i = self_i * value
    void scale(in double value);
    // Copy self into y
    void copy(in Vec y);
    // self_i = value
    // ERROR: NOT CHANGED IN PETSc YET
    void set(in double value);
    // Swap the values in self and y
    void swap(in Vec y);
    // self_i = a * x_i + self_i
    // ERROR: NOT CHANGED IN PETSc YET
    void AXPY(in double a, in Vec x);  
    // self_i = x_i + a * self_i
    void AYPX(in double a, in Vec x);
    // self_i = a * x_i + b * self_i
    void AXPBY(in double a, in double b, in Vec x);
    // self_i = \sum_i a_i x_i + self_i
    void MAXPY(in array<double> a, in array<Vec> x);
    // self_i = a x_i + y_i
    void WAXPY(in double a, in Vec x, in Vec y);
    // self_i = max(x_i, y_i)
    void pointwiseMax(in Vec x, in Vec y);
    // self_i = max(|x_i|, |y_i|)
    void pointwiseMaxAbs(in Vec x, in Vec y);
    // self_i = min(x_i, y_i)
    void pointwiseMin(in Vec x, in Vec y);
    // self_i = x_i y_i
    void pointwiseMult(in Vec x, in Vec y);
    // self_i = x_i / y_i
    void pointwiseDivide(in Vec x, in Vec y);
    // result = max_i |x_i / y_i|
    double maxPointwiseDivide(in Vec y);
    // self_i = self_i + value
    void shift(in double value);
    // self_i = 1 / self_i
    void reciprocal();
    // self_i = \sqrt{self_i}
    void sqrt();
    // self_i = |self_i|
    void abs();
    // Duplicates the vector (does not copy values)
    Vec duplicate();          
    // Return the layout of the vector
    PetscMap getPetscMap();
    // Set values into the vector
    void setValues(in array<int> indices, in array<double> values, in InsertMode mode);
    // Start parallel assembly
    void assemblyBegin();
    // Finish parallel assembly
    void assemblyEnd();
    // Get the block size
    int getBlockSize();
    // Set the block size
    void setBlockSize(in int size);
    // Set values into the vector
    void setValuesBlocked(in array<int> indices, in array<double> values, in InsertMode mode);
    // Get the local storage
    array<double>:values getArray();
    // Return the local storage
    void restoreArray(in array<double> values);
    // result = (self == y)
    bool equal(in Vec y);
  }

  enum MatAssemblyType {MAT_FINAL_ASSEMBLY, MAT_FLUSH_ASSEMBLY};

  enum MatReuse {MAT_INITIAL_MATRIX, MAT_REUSE_MATRIX};

  enum MatDuplicateOption {MAT_DO_NOT_COPY_VALUES, MAT_COPY_VALUES};

  enum MatStructure {SAME_NONZERO_PATTERN, DIFFERENT_NONZERO_PATTERN, SAME_PRECONDITIONER, SUBSET_NONZERO_PATTERN};

  enum MatOption {MAT_ROW_ORIENTED=1,MAT_COLUMN_ORIENTED=2,MAT_ROWS_SORTED=4,
      MAT_COLUMNS_SORTED=8,MAT_NO_NEW_NONZERO_LOCATIONS=16,
      MAT_YES_NEW_NONZERO_LOCATIONS=32,MAT_SYMMETRIC=64,
      MAT_STRUCTURALLY_SYMMETRIC=65,MAT_NO_NEW_DIAGONALS=66,
      MAT_YES_NEW_DIAGONALS=67,MAT_INODE_LIMIT_1=68,MAT_INODE_LIMIT_2=69,
      MAT_INODE_LIMIT_3=70,MAT_INODE_LIMIT_4=71,MAT_INODE_LIMIT_5=72,
      MAT_IGNORE_OFF_PROC_ENTRIES=73,MAT_ROWS_UNSORTED=74,
      MAT_COLUMNS_UNSORTED=75,MAT_NEW_NONZERO_LOCATION_ERR=76,
      MAT_NEW_NONZERO_ALLOCATION_ERR=77,MAT_USE_HASH_TABLE=78,
      MAT_KEEP_ZEROED_ROWS=79,MAT_IGNORE_ZERO_ENTRIES=80,MAT_USE_INODES=81,
      MAT_DO_NOT_USE_INODES=82,MAT_NOT_SYMMETRIC=83,MAT_HERMITIAN=84,
      MAT_NOT_STRUCTURALLY_SYMMETRIC=85,MAT_NOT_HERMITIAN=86,
      MAT_SYMMETRY_ETERNAL=87,MAT_NOT_SYMMETRY_ETERNAL=88,
      MAT_USE_COMPRESSEDROW=89,MAT_DO_NOT_USE_COMPRESSEDROW=90,
      MAT_IGNORE_LOWER_TRIANGULAR=91,MAT_ERROR_LOWER_TRIANGULAR=92};

  class Mat implements PetscObject {
    // Set the local and global number of rows and columns
    void setSizes(in int m, in int n, in int M, in int N);
    // Get values from the matrix
    void getValues(in array<int> rowIndices, in array<int> colIndices, in array<double> values);
    // Set values into the matrix
    void setValues(in array<int> rowIndices, in array<int> colIndices, in array<double> values, in InsertMode mode);
    // Get the block size
    void getBlockSize(out int size);
    // Set the block size
    void setBlockSize(in int size);
    // Set values into the matrix
    void setValuesBlocked(in array<int> rowIndices, in array<int> colIndices, in array<double> values, in InsertMode mode);
    // Set the grid information for setting values into a matrix stencil
    //   sizes: The number of grid points in each dimension
    //   starts: The first node in each dimension in this domain (including ghost points)
    //   dof: The number of degrees of freedom per node
    void setStencil(in array<int> sizes, in array<int> starts, in int dof);
    // Set values into the matrix
    void setValuesStencil(in array<int> rowIndices, in array<int> colIndices, in array<double> values, in InsertMode mode);
    // Set values into the matrix
    void setValuesBlockedStencil(in array<int> rowIndices, in array<int> colIndices, in array<double> values, in InsertMode mode);
    // Get the local storage
    array<double>:values getArray();
    // Return the local storage
    void restoreArray(in array<double> values);
    // Begin the assembly phase
    void assemblyBegin(in MatAssemblyType assemblyType);
    // End the assembly phase
    void assemblyEnd(in MatAssemblyType assemblyType);
    // Load the matrix from a viewer
    static void load(in PetscViewer viewer, in string typename, out Mat A);

    // The matrix-vector product y = Ax
    void mult(in Vec x, in Vec y);
    // The matrix-vector product z = Ax + y
    void multAdd(in Vec x, in Vec y, in Vec z);
    // The transposed matrix-vector product y = A^T x
    void multTranspose(in Vec x, in Vec y);
    // The transposed matrix-vector product z = A^T x + y
    void multTransposeAdd(in Vec x, in Vec y, in Vec z);

    // Get the global sizes
    void getSize(out int numRows, out int numCols);
    // Get the local sizes
    void getLocalSize(out int numLocalRows, out int numLocalCols);
    // Get the range of local rows
    void getOwnershipRange(out int startRow, out int endRow);
    // Get the row and column layouts
    void getPetscMaps(out PetscMap rowLayout, out PetscMap colLayout);
    // Get the diagonal entires as a Vec
    void getDiagonal(in Vec diag);
    // Test for equality A = B
    bool equal(in Mat B);
    // Test for transpose identity A^T = B
    bool isTranspose(in Mat B, in double tol);
    // Test for symmetry
    bool isSymmetric(in double tol);
    // Test for structural symmetry
    bool isStructurallySymmetric();
    // Test for complex symmetry
    bool isHermitian();

    // Customize the matrix
    void setOption(in MatOption option);
    // Convert the matrix to a different type
    void convert(in string newType, in MatReuse reuseFlag, out Mat newMat);
    // Duplicate the matrix
    void duplicate(in MatDuplicateOption duplicationFlag, out Mat newMat);
    // Copy the matrix
    void copy(in Mat B, in MatStructure copyFlag);
    // Return the transpose B = A^T
    void transpose(out Mat B);
    // Replace A with its Hermitian conjugate A^{\dagger}
    void conjugate();
    // Scale by a diagonal matrix on the left and right (represented as a Vec)
    void diagonalScale(in Vec left, in Vec right);
    // Set A = 0
    void zeroEntries();
    // Replace rows of A with a single diagonal element
    void zeroRows(in array<int> indices, in double diagValue);
    // Scale all elements by alpha
    void scale(in double alpha);
    // Shift all elements by alpha
    void shift(in double alpha);
  }

  enum PCSide {PC_LEFT, PC_RIGHT, PC_SYMMETRIC};

  class PC implements PetscObject {
    // Setup local preconditioner blocks
    void setUpOnBlocks();
    // Apply the preconditioner M^{-1} x = y
    void apply(in Vec x, in Vec y);
    // Apply the preconditioner M_L^{-1/2} x = y
    void applySymmetricLeft(in Vec x, in Vec y);
    // Apply the preconditioner M_R^{-1/2} x = y
    void applySymmetricRight(in Vec x, in Vec y);
    // Apply M^{-1} to x and store the result in y
    void applyBAorAB(in PCSide side, in Vec x, in Vec y, in Vec work);
    // Apply the preconditioner M^{-T} x = y
    void applyTranspose(in Vec x, in Vec y);
    // Determine whether M^{-T} is available
    bool hasApplyTranspose();
    // Apply M^{-T} to x and store the result in y
    void applyBAorABTranspose(in PCSide side, in Vec x, in Vec y, in Vec work);
    // Apply Richardson exstrapolation
    void applyRichardson(in Vec x, in Vec y, in Vec work, in double relativeTol, in double absoluteTol, in double divergenceTol, in int numIterations);
    // Determine whether Richardson extrapolation is available
    void applyRichardsonExists(out bool richardsonExists);
  }

  enum KSPNormType {KSP_NO_NORM, KSP_PRECONDITIONED_NORM, KSP_UNPRECONDITIONED_NORM, KSP_NATURAL_NORM};

  enum KSPConvergedReason {KSP_CONVERGED_ITERATING          = 0,
                           KSP_CONVERGED_ATOL               =  3,
                           KSP_CONVERGED_RTOL               =  2,
                           KSP_CONVERGED_ITS                =  4,
                           KSP_CONVERGED_QCG_NEG_CURVE      =  5,
                           KSP_CONVERGED_QCG_CONSTRAINED    =  6,
                           KSP_CONVERGED_STEP_LENGTH        =  7,
                           KSP_DIVERGED_NULL                = -2,
                           KSP_DIVERGED_ITS                 = -3,
                           KSP_DIVERGED_DTOL                = -4,
                           KSP_DIVERGED_BREAKDOWN           = -5,
                           KSP_DIVERGED_BREAKDOWN_BICG      = -6,
                           KSP_DIVERGED_NONSYMMETRIC        = -7,
                           KSP_DIVERGED_INDEFINITE_PC       = -8,
                           KSP_DIVERGED_NAN                 = -9,
                           KSP_DIVERGED_INDEFINITE_MAT      = -10};

  class KSP implements PetscObject {
    // Solve the linear system A x = b
    void solve(in Vec b, in Vec x);
    // Solve the linear system A^T x = b
    void solveTranspose(in Vec b, in Vec x);

    // Get the matrix A and preconditioning matrix M
    void getOperators(out Mat A, out Mat M, out MatStructure flag);
    // Set the matrix A and preconditioning matrix M
    void setOperators(in Mat A, in Mat M, in MatStructure flag);
    // Get the preconditioner
    PC getPC();
    // Set the preconditioner
    void setPC(in PC preconditioner);
    // Get the preconditioner application type
    PCSide getPreconditionerSide();
    // Set the preconditioner application type
    void setPreconditionerSide(in PCSide side);
    // Get the solution tolerances
    void getTolerances(out double relativeTol, out double absoluteTol, out double divergenceTol, out int maxIterations);
    // Set the solution tolerances
    void setTolerances(in double relativeTol, in double absoluteTol, in double divergenceTol, in int maxIterations);
    // Get the flag for a nonzero initial guess
    bool getInitialGuessNonzero();
    // Set the flag for a nonzero initial guess
    void setInitialGuessNonzero(in bool nonzeroGuess);
    // Get the flag for computing eigenvalues of the reduced matrix
    bool getComputeEigenvalues();
    // Set the flag for computing eigenvalues of the reduced matrix
    void setComputeEigenvalues(in bool computeEigenvalues);
    // Get the flag for computing singular values of the reduced matrix
    bool getComputeSingularValues();
    // Set the flag for computing singular values of the reduced matrix
    void setComputeSingularValues(in bool computeSingularValues);
    // Set the type of norm used to check convergence of the solver
    void setNormType(in KSPNormType normType);

    // Set the function which is used to check convergence of the solver
    //   Must be called after the KSP type has been set so put this after
    //   a call to KSPSetType(), or KSPSetFromOptions().
    //
    //   Calling sequence of convergence test:
    //     reason convergenceTest(ksp, iterationNumber, residualNorm)
    void setConvergenceTest(in function convergenceTest);

    // Get the rhs
    Vec getRhs();
    // Get the solution
    Vec getSolution();
    // Get the norm of the residual b - A x
    double getResidualNorm();
    // Get the number of iterates performed
    int getIterationNumber();
    // Get the reason for solver termination
    KSPConvergedReason getConvergedReason();
  }

  // Convergence
  //   SNES_CONVERGED_ITERATING      still iterating
  //   SNES_CONVERGED_FNORM_ABS      F < F_minabs
  //   SNES_CONVERGED_FNORM_RELATIVE F < F_mintol*F_initial
  //   SNES_CONVERGED_PNORM_RELATIVE step size small
  //   SNES_CONVERGED_TR_DELTA       trust region tol???
  // Divergence
  //   SNES_DIVERGED_FUNCTION_COUNT  too many function evaluations
  //   SNES_DIVERGED_FNORM_NAN       encountered NaN in residual
  //   SNES_DIVERGED_MAX_IT          too many iterations
  //   SNES_DIVERGED_LS_FAILURE      line search did not produce descent
  //   SNES_DIVERGED_LOCAL_MIN       || J^T b || is small, implies converged to local minimum of F()
  enum SNESConvergedReason {SNES_CONVERGED_ITERATING = 0, SNES_CONVERGED_FNORM_ABS = 2, SNES_CONVERGED_FNORM_RELATIVE = 3,
                            SNES_CONVERGED_PNORM_RELATIVE = 4, SNES_CONVERGED_TR_DELTA = 7,
                            SNES_DIVERGED_FUNCTION_COUNT = -2, SNES_DIVERGED_FNORM_NAN = -4, SNES_DIVERGED_MAX_IT = -5,
                            SNES_DIVERGED_LS_FAILURE = -6, SNES_DIVERGED_LOCAL_MIN = -8};


  class SNES implements PetscObject {
    // Retrieve the linear solver
    PETSc.KSP getKSP();

    // Get the constant part
    Vec getRhs();
    // Set the constant part
    void setRhs(in Vec b);
    // Get the function which calculates the residual F
    void getFunction(out PETSc.Vec f, out function func);
    // Set the function which calculates the residual F
    void setFunction(in PETSc.Vec f, in function func);
    // Get the function which calculates the Jacobian J
    void getJacobian(out PETSc.Mat J, out PETSc.Mat M, out function func);
    // Set the function which calculates the jacobian J
    void setJacobian(in PETSc.Mat J, in PETSc.Mat M, in function jacobian);

    // Compute the residual F(x)
    void computeFunction(in PETSc.Vec x, in PETSc.Vec f);
    // Compute the jacobian J(x)
    void computeJacobian(in PETSc.Vec x, out PETSc.Mat J, out PETSc.Mat M, out PETSc.MatStructure flag);

    // Get the solver tolerances:
    //   absolute residual tolerance
    //   relative residual tolerance
    //   absolute solution update tolerance
    //   maximum iteration count
    //   maximum function evaluation count
    void getTolerances(out double abstol, out double rtol, out double stol, out int maxit, out int maxf);
    // Set the solver tolerances:
    //   absolute residual tolerance
    //   relative residual tolerance
    //   absolute solution update tolerance
    //   maximum iteration count
    //   maximum function evaluation count
    void setTolerances(in double abstol, in double rtol, in double stol, in int maxit, in int maxf);

    // Solve the system of nonlinear algebraic equations
    void solve(in PETSc.Vec b, in PETSc.Vec x);
    // Get the solution vector
    PETSc.Vec getSolution();
    // Get the reason for termination of the solver
    SNESConvergedReason getConvergedReason();
    // Get the number of solver iterates
    int getIterationNumber();
    // Get the number of linear solver iterates
    int getNumberLinearIterations();
    // Get the residual norm
    double getFunctionNorm();
  }
}